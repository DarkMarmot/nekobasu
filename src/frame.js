import F from './flib.js';


class Frame {

    constructor(bus, streams) {

        this._bus = bus;
        this._index = bus._frames.length;
        this._holding = false; //begins group, keep, schedule frames
        this._streams = streams || [];
        this._eachStream('debugFrame', this);

    };

    get bus() {
        return this._bus;
    };

    get index() {
        return this._index;
    };

    get holding() {
        return this._holding;
    };

    get streams() {
        return [].concat(this._streams);
    }

    _eachStream(prop, val){

        const streams = this._streams;
        const len = streams.length;

        for(let i = 0; i < len; i++){

            const stream = streams[i];
            stream[prop] = val;

        }

        return this;

    };

    // properties are generated by calling f to build closure states
    _eachStreamGen(prop, f){

        const streams = this._streams;
        const len = streams.length;

        for(let i = 0; i < len; i++){

            const stream = streams[i];
            stream[prop] = f();

        }

        return this;

    };

    _eachStreamCall(method, val){

        const streams = this._streams;
        const len = streams.length;

        for(let i = 0; i < len; i++){

            const stream = streams[i];
            stream[method].call(stream, val);

        }

        return this;

    };

    _eachPool(prop, val){

        const streams = this._streams;
        const len = streams.length;

        for(let i = 0; i < len; i++){

            const stream = streams[i];
            const pool = stream.pool;
            pool[prop] = val;

        }

        return this;

    };

    _eachPoolCall(method, val){

        const streams = this._streams;
        const len = streams.length;

        for(let i = 0; i < len; i++){

            const stream = streams[i];
            const pool = stream.pool;
            pool[method].call(pool, val);

        }

        return this;

    };
    
    run(func){

        this._eachStream('actionMethod', func);
        this._eachStreamCall('process', 'doRun');

        return this;

    };

    hold(){

        this._holding = true;
        this._eachStreamCall('createPool');
        this._eachStreamCall('process', 'doPool');

        return this;

    };

    transform(fAny){

        fAny = F.FUNCTOR(fAny);

        this._eachStreamCall('process', 'doTransform');
        this._eachStream('actionMethod', fAny);

        return this;

    };

    name(fStr){

        fStr = F.FUNCTOR(fStr);

        this._eachStreamCall('process', 'doName');
        this._eachStream('actionMethod', fStr);

        return this;

    };


    delay(fNum){

        F.ASSERT_NEED_ONE_ARGUMENT(arguments);

        fNum = F.FUNCTOR(fNum);

        this._eachStream('actionMethod', fNum);
        this._eachStreamCall('process', 'doDelay');

        return this;

    };


    filter(func){

        this._eachStream('actionMethod', func);
        this._eachStreamCall('process', 'doFilter');

        return this;
    };

    skipDupes() {

        this._eachStreamGen('actionMethod', F.getSkipDupes);
        this._eachStreamCall('process', 'doFilter');

    };


    // factory should define content and reset methods have signature f(msg, source) return f.content()
    reduce(factory, ...args){

        this._eachPool('keep', factory(...args));
        return this;

    };


    batch(){

        this._holding = false; // holds end with timer
        this._eachPoolCall('batch');

        return this;

    };

    sync(){

        this._holding = false;
        this._eachPoolCall('sync');

    }

    ready(func){

        F.ASSERT_NEED_ONE_ARGUMENT(arguments);
        F.ASSERT_IS_FUNCTION(func);

        this._eachStream('readyMethod', func);
        return this;

    };


    destroy(){

        const streams = this._streams;
        const len = streams.length;
        for(let i = 0; i < len; i++){
            streams[i].cleanupMethod();
        }
        this._streams = null;

    };
    
}

export default Frame;


