{"version":3,"file":"catbus.umd.min.js","sources":["../src/dataTypes.js","../src/flib.js","../src/bus.js","../src/packet.js","../src/subscriberList.js","../src/data.js","../src/scope.js","../src/pool.js","../src/stream.js","../src/poolAspects.js","../src/frame.js","../src/catbus.js"],"sourcesContent":["\n\nconst DATA_TYPES = {\n\n    ACTION:   'action',\n    MIRROR:   'mirror',\n    STATE:    'state',\n    COMPUTED: 'computed',\n    NONE:     'none',\n    ANY:      'any'\n\n};\n\nconst reverseLookup = {};\n\nfor(const p in DATA_TYPES){\n    const v = DATA_TYPES[p];\n    reverseLookup[v] = p;\n}\n\nfunction isValid(type){\n    return reverseLookup.hasOwnProperty(type);\n}\n\n\nexport { DATA_TYPES, isValid};\n\n","\nimport Catbus from './catbus.js';\n\nfunction ALWAYS_TRUE(){\n    return true;\n}\n\nfunction ALWAYS_FALSE(){\n    return false;\n}\n\nfunction TO_SOURCE(msg, source) {\n    return source;\n}\n\nfunction TO_MSG(msg, source) {\n    return msg;\n}\n\nfunction NOOP(){\n\n}\n\n\nfunction FUNCTOR(val) {\n    return (typeof val === 'function') ? val : function() { return val; };\n}\n\nconst Func = {\n\n    ASSERT_NEED_ONE_ARGUMENT: function(args){\n        if(args.length < 1)\n            throw new Error('Method requires at least one argument.');\n    },\n\n    ASSERT_IS_FUNCTION: function(func){\n        if(typeof func !== 'function')\n            throw new Error('Argument [func] is not of type function.');\n    },\n\n    getAlwaysTrue: function(){\n       return function(){ return true;}\n    },\n\n    getBatchTimer: function(){\n        const pool = this;\n        return function() {\n            Catbus.enqueue(pool);\n        }\n    },\n\n    getSyncTimer: function(){\n        const pool = this;\n        return function() {\n            pool.release(pool);\n        }\n    },\n\n    getDeferTimer: function(){\n        const pool = this;\n        return function() {\n            setTimeout(pool.release, 0, pool);\n        }\n    },\n\n    getThrottleTimer: function(fNum){\n\n        const pool = this;\n        fNum = FUNCTOR(fNum);\n        let wasEmpty = false;\n        let timeoutId = null;\n        let msgDuringTimer = false;\n        const auto = pool.keep.auto;\n\n        function timedRelease(fromTimeout){\n\n            if(pool.stream.dead)\n                return;\n\n            const nowEmpty = pool.keep.isEmpty;\n\n            if(!fromTimeout){\n                if(!timeoutId) {\n                    pool.release(pool);\n                    wasEmpty = false;\n                    timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n                } else {\n                    msgDuringTimer = true;\n                }\n                return;\n            }\n\n            if(nowEmpty){\n                if(wasEmpty){\n                    // throttle becomes inactive\n                } else {\n                    // try one more time period to maintain throttle\n                    wasEmpty = true;\n                    msgDuringTimer = false;\n                    timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n                }\n            } else {\n                pool.release(pool);\n                wasEmpty = false;\n                timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n            }\n\n        }\n\n        return timedRelease;\n\n    },\n\n    getQueue: function(n){\n\n        n = n || Infinity;\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            if(buffer.length < n)\n                buffer.push(msg);\n            return buffer;\n        };\n\n        f.isBuffer = ALWAYS_TRUE;\n\n        f.next = function(){\n            return buffer.shift();\n        };\n\n        f.isEmpty = function(){\n            return buffer.length === 0;\n        };\n\n        f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getScan: function(func, seed){\n\n        const hasSeed = arguments.length === 2;\n        let acc;\n        let initMsg = true;\n\n        const f = function(msg, source){\n\n            if(initMsg){\n                initMsg = false;\n                if(hasSeed){\n                    acc = func(seed, msg, source);\n                } else {\n                    acc = msg;\n                }\n            } else {\n                acc = func(acc, msg, source);\n            }\n\n            return acc;\n\n        };\n\n        f.reset = NOOP;\n\n        f.next = f.content = function(){\n            return acc;\n        };\n\n\n        return f;\n    },\n\n    getGroup: function(groupBy){\n\n        groupBy = groupBy || TO_SOURCE;\n        const hash = {};\n\n        const f = function(msg, source){\n\n            const g = groupBy(msg, source);\n            hash[g] = msg;\n            return hash;\n\n        };\n\n        f.reset = function(){\n            for(const k in hash){\n                delete hash[k];\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return hash;\n        };\n\n        return f;\n\n    },\n\n    getKeepLast: function(n){\n\n        if(!n || n < 0) {\n\n            let last;\n\n            const f = function(msg, source){\n                return last = msg;\n            };\n\n            f.reset = function(){\n                f.isEmpty = true;\n            };\n\n            f.next = f.content = function(){\n                return last;\n            };\n\n            return f;\n\n        }\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            buffer.push(msg);\n            if(buffer.length > n)\n                buffer.shift();\n            return buffer;\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n\n\n    getKeepFirst: function(n){\n\n        if(!n || n < 0) {\n\n            let firstMsg;\n            let hasFirst = false;\n            const f = function (msg, source) {\n                return hasFirst ? firstMsg : firstMsg = msg;\n            };\n\n            f.reset = function(){\n                firstMsg = false;\n                f.isEmpty = true;\n            };\n\n            f.next = f.content = function(){\n                return firstMsg;\n            };\n\n            return f;\n        }\n\n        const buffer = [];\n\n        const f = function(msg, source){\n\n            if(buffer.length < n)\n                buffer.push(msg);\n            return buffer;\n\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getKeepAll: function(){\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            buffer.push(msg);\n            return buffer;\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getWhenCount: function(n) {\n\n        let latched = false;\n\n        const f = function(messages){\n            latched = latched || messages.length >= n;\n            return latched;\n        };\n\n        f.reset = function(){\n            latched = false;\n        };\n\n        return f;\n\n    },\n\n    getWhenKeys: function(keys) {\n\n        const keyHash = {};\n        const len = keys.length;\n\n        for(let i = 0; i < len; i++){\n            const k = keys[i];\n            keyHash[k] = true;\n        }\n\n        let latched = false;\n\n        const f = function (messagesByKey) {\n\n            if(latched)\n                return true;\n\n            for (let i = 0; i < len; i++) {\n                const k = keys[i];\n                if (!messagesByKey.hasOwnProperty(k))\n                    return false;\n            }\n\n            return latched = true;\n\n        };\n\n        f.reset = function(){\n            latched = false;\n            for(const k in keyHash){\n                delete keyHash[k];\n            }\n        };\n\n        return f;\n\n    },\n\n    getSkipDupes: function() {\n\n        let hadMsg = false;\n        let lastMsg;\n\n        return function (msg) {\n\n            const diff = !hadMsg || msg !== lastMsg;\n            lastMsg = msg;\n            hadMsg = true;\n            return diff;\n\n        }\n\n    },\n\n\n    ASSERT_NOT_HOLDING: function(bus){\n        if(bus.holding)\n            throw new Error('Method cannot be invoked while holding messages in the frame.');\n    },\n\n    ASSERT_IS_HOLDING: function(bus){\n        if(!bus.holding)\n            throw new Error('Method cannot be invoked unless holding messages in the frame.');\n    }\n\n};\n\nFunc.TO_SOURCE = TO_SOURCE;\nFunc.To_MSG = TO_MSG;\nFunc.FUNCTOR = FUNCTOR;\nFunc.ALWAYS_TRUE = ALWAYS_TRUE;\nFunc.ALWAYS_FALSE = ALWAYS_FALSE;\nFunc.NOOP = NOOP;\n\nexport default Func;","\nimport Frame from './frame.js';\nimport F from './flib.js';\nimport Stream from './stream.js';\n\n\nclass Bus {\n\n    constructor(streams) {\n\n        this._frames = [];\n        this._dead = false;\n        this._scope = null;\n        const f = new Frame(this, streams);\n        this._frames.push(f);\n        this._currentFrame = f;\n\n    };\n\n    get dead() {\n        return this._dead;\n    };\n\n    get holding() {\n        return this._currentFrame._holding;\n    };\n\n    addFrame() {\n\n        const lastFrame = this._currentFrame;\n        const nextFrame = this._currentFrame = new Frame(this);\n        this._frames.push(nextFrame);\n\n        _wireFrames(lastFrame, nextFrame);\n\n        return nextFrame;\n    };\n\n    // create a new frame with one stream fed by all streams of the current frame\n\n    mergeFrame() {\n\n        const mergedStream = new Stream();\n\n        const lastFrame = this._currentFrame;\n        const nextFrame = this._currentFrame = new Frame(this, [mergedStream]);\n        this._frames.push(nextFrame);\n\n        const streams = lastFrame._streams;\n        const len = streams.length;\n        for (let i = 0; i < len; i++) {\n            const s = streams[i];\n            s.addTarget(mergedStream);\n        }\n\n        return this;\n\n    };\n\n    // create stream\n    spawn(){\n\n    }\n\n    // convert each stream into a bus, dump in array\n\n    split(){\n\n        F.ASSERT_NOT_HOLDING(this);\n\n    };\n\n    fork() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        const fork = new Bus();\n        _wireFrames(this._currentFrame, fork._currentFrame);\n\n        return fork;\n    };\n\n    add(bus) {\n\n        const frame = this.addFrame(); // wire from current bus\n        _wireFrames(bus._currentFrame, frame); // wire from outside bus\n        return this;\n\n    };\n\n    defer() {\n        return this.timer(F.getDeferTimer);\n    };\n\n    batch() {\n        return this.timer(F.getBatchTimer);\n    };\n\n    sync() {\n        return this.timer(F.getSyncTimer);\n    };\n\n    throttle(fNum) {\n        return this.timer(F.getThrottleTimer, fNum);\n    };\n\n    hold() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().hold();\n        return this;\n\n    };\n\n    scan(func, seed){\n        this.reduce(F.getScan, func, seed);\n    };\n\n    delay(num) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().delay(num);\n        return this;\n\n    };\n\n    willReset(){\n\n        F.ASSERT_IS_HOLDING(this);\n        return this.clear(F.getAlwaysTrue);\n\n    }\n\n    whenKeys(keys) {\n        F.ASSERT_IS_HOLDING(this);\n        return this.when(F.getWhenKeys, keys);\n    };\n\n    group(by) {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().hold().reduce(F.getGroup, by);\n        return this;\n    };\n\n    all() {\n        return this.reduce(F.getKeepAll);\n    };\n\n    first(n) {\n        return this.reduce(F.getKeepFirst, n);\n    };\n\n    last(n) {\n        return this.reduce(F.getKeepLast, n);\n    };\n\n    clear(factory, ...args) {\n        return this._currentFrame.clear(factory, ...args);\n    };\n\n    reduce(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.reduce(factory, ...args) :\n            this.addFrame().hold().reduce(factory, ...args).timer(F.getSyncTimer);\n        return this;\n\n    };\n\n    timer(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.timer(factory, ...args) :\n            this.addFrame().hold().timer(factory, ...args);\n        return this;\n\n    };\n\n    until(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.until(factory, ...args) :\n            this.addFrame().hold().until(factory, ...args).timer(F.getSyncTimer);\n        return this;\n\n    };\n\n    when(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.when(factory, ...args) :\n            this.addFrame().hold().when(factory, ...args).timer(F.getSyncTimer);\n        return this;\n\n    };\n\n    run(func) {\n\n        F.ASSERT_IS_FUNCTION(func);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().run(func);\n        return this;\n\n    };\n\n    merge() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.mergeFrame();\n        return this;\n    };\n\n    transform(fAny) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().transform(fAny);\n        return this;\n\n    };\n\n    name(fStr) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().name(fStr);\n        return this;\n\n    };\n\n    filter(func) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_IS_FUNCTION(func);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().filter(func);\n        return this;\n\n    };\n\n    skipDupes() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().skipDupes();\n        return this;\n\n    };\n\n    toStream() {\n        // merge, fork -> immutable stream?\n    };\n\n    destroy() {\n\n        if (this.dead)\n            return this;\n\n        this._dead = true;\n\n        const frames = this._frames;\n\n        for (const f of frames) {\n            f.destroy();\n        }\n\n        return this;\n\n    };\n\n}\n\n// send messages from streams in one frame to new empty streams in another frame\n// injects new streams to frame 2\n\nfunction _wireFrames(frame1, frame2) {\n\n    const streams1 = frame1._streams;\n    const streams2 = frame2._streams;\n\n    const len = streams1.length;\n\n    for (let i = 0; i < len; i++) {\n\n        const s1 = streams1[i];\n        const s2 = new Stream(frame2);\n        s2.name = s1.name;\n        streams2.push(s2);\n        s1.addTarget(s2);\n\n    }\n\n}\n\n\nexport default Bus;\n","\nclass Packet {\n\n    constructor(msg, topic, source) {\n        this._msg       = msg;\n        this._topic     = topic;\n        this._source    = source;\n        this._timestamp = Date.now();\n    };\n\n    get msg() { return this._msg; };\n    get topic() { return this._topic; };\n    get source() { return this._source; };\n    get timestamp() { return this._timestamp; };\n\n}\n\nexport default Packet;","\nimport Packet from './packet.js';\nimport { DATA_TYPES } from './dataTypes';\n\nclass SubscriberList {\n\n    constructor(topic, data) {\n\n        this._topic = topic;\n        this._subscribers = [];\n        this._lastPacket = null;\n        this._data = data;\n        this._name = data._name;\n        this._dead = false;\n\n    };\n\n    get lastPacket() { return this._lastPacket; };\n    get data() { return this._data; };\n    get name() { return this._name; };\n    get dead() { return this._dead; };\n    get topic() { return this._topic; };\n\n    tell(msg, topic, silently){\n\n        if(this.dead)\n            return;\n\n        topic = topic || this.topic;\n        let source = this.name;\n        let currentPacket = new Packet(msg, topic, source);\n\n        if(this.data.type !== DATA_TYPES.ACTION) // actions do not store data (ephemeral and immediate)\n            this._lastPacket = currentPacket;\n\n        let subscribers = [].concat(this._subscribers); // call original sensors in case subscriptions change mid loop\n        let len = subscribers.length;\n\n        if(!silently) {\n            for (let i = 0; i < len; i++) {\n                let s = subscribers[i];\n                typeof s === 'function' ? s.call(s, msg, currentPacket) : s.tell(msg, currentPacket);\n            }\n        }\n\n    };\n\n    destroy(){\n\n        if(this.dead)\n            return;\n\n        this._subscribers = null;\n        this._lastPacket = null;\n        this._dead = true;\n\n    };\n\n    add(watcher){\n\n        this._subscribers.push(watcher);\n\n    };\n\n    remove(watcher){\n\n        let i = this._subscribers.indexOf(watcher);\n\n        if(i !== -1)\n            this._subscribers.splice(i, 1);\n\n    };\n\n}\n\n\nexport default SubscriberList;\n\n","\nimport SubscriberList from './subscriberList.js';\nimport {isValid, DATA_TYPES} from './dataTypes.js';\n\n\nclass Data {\n\n    constructor(scope, name, type) {\n\n        type = type || DATA_TYPES.NONE;\n\n        if(!isValid(type))\n            throw new Error('Invalid Data of type: ' + type);\n\n        this._scope      = scope;\n        this._name       = name;\n        this._type       = type;\n        this._dead       = false;\n\n        this._noTopicSubscriberList = new SubscriberList(null, this);\n        this._wildcardSubscriberList = new SubscriberList(null, this);\n        this._subscriberListsByTopic = new Map();\n\n    };\n\n    get scope() { return this._scope; };\n    get name() { return this._name; };\n    get type() { return this._type; };\n    get dead() { return this._dead; };\n\n    destroy(){\n\n        if(this.dead)\n            this._throwDead();\n        \n        for(const list of this._subscriberListsByTopic.values()){\n            list.destroy();\n        }\n\n        this._dead = true;\n\n    };\n    \n    _demandSubscriberList(topic){\n\n        let list = this._subscriberListsByTopic.get(topic);\n\n        if(list)\n            return list;\n\n        list = new SubscriberList(topic, this);\n        this._subscriberListsByTopic.set(topic, list);\n\n        return list;\n        \n    };\n\n    verify(expectedType){\n\n        if(this.type === expectedType)\n            return this;\n\n        throw new Error('Data ' + this.name + ' requested as type ' + expectedType + ' exists as ' + this.type);\n\n    };\n\n    follow(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        this.subscribe(watcher, topic);\n        let packet = this.peek();\n\n        if(packet)\n            typeof watcher === 'function' ? watcher.call(watcher, packet.msg, packet) : watcher.tell(packet.msg, packet);\n\n        return this;\n\n    };\n\n    subscribe(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        const subscriberList = (!topic) ? this._noTopicSubscriberList : this._demandSubscriberList(topic);\n        subscriberList.add(watcher);\n\n        return this;\n\n    };\n\n    monitor(watcher){\n\n        if(this.dead)\n            this._throwDead();\n\n        this._wildcardSubscriberList.add(watcher);\n\n        return this;\n\n    };\n\n    unsubscribe(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        if(typeof topic !== 'string'){\n            this._noTopicSubscriberList.remove(watcher);\n        } else {\n            let subscriberList = this._demandSubscriberList(topic);\n            subscriberList.remove(watcher);\n        }\n        this._wildcardSubscriberList.remove(watcher);\n\n        return this;\n\n    };\n\n\n\n    peek(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        let subscriberList = topic ? this._subscriberListsByTopic.get(topic) : this._noTopicSubscriberList;\n        if(!subscriberList)\n            return null;\n        return subscriberList.lastPacket;\n\n    };\n\n\n    read(topic) {\n\n        if(this.dead)\n            this._throwDead();\n\n        let packet = this.peek(topic);\n        return (packet) ? packet.msg : undefined;\n\n    };\n\n\n    silentWrite(msg, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        this.write(msg, topic, true);\n\n    };\n\n\n    write(msg, topic, silently){\n\n        if(this.dead)\n            this._throwDead();\n\n        if(this.type === DATA_TYPES.MIRROR)\n            throw new Error('Mirror Data: ' + this.name + ' is read-only');\n\n        if(topic) {\n            let list = this._demandSubscriberList(topic);\n            list.tell(msg);\n        }\n        else {\n            this._noTopicSubscriberList.tell(msg, null, silently);\n        }\n\n        this._wildcardSubscriberList.tell(msg, topic, silently);\n\n    };\n\n\n    refresh(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        this.write(this.read(topic), topic);\n\n        return this;\n\n    };\n\n\n    toggle(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        this.write(!this.read(topic), topic);\n\n        return this;\n\n    };\n\n    _throwDead(){\n\n        throw new Error('Data: ' + this.name + ' is already dead.');\n\n    };\n\n}\n\nexport default Data;\n\n\n\n\n\n\n\n\n\n\n\n\n","\nimport Data from './data.js';\nimport { DATA_TYPES, isValid } from './dataTypes.js';\n\nlet idCounter = 0;\n\nclass Scope{\n\n    constructor(name) {\n\n        this._id = ++idCounter;\n        this._name = name;\n        this._parent = null;\n        this._children = [];\n        this._dataList = new Map();\n        this._valves = new Map();\n        this._mirrors = new Map();\n        this._dead = false;\n\n    };\n\n\n\n    get name() { return this._name; };\n    get dead() { return this._dead; };\n\n    get children(){\n\n        return this._children.map((d) => d);\n\n    };\n\n    clear(){\n\n        if(this._dead)\n            return;\n\n        for(const child of this._children){\n            child.destroy();\n        }\n\n        for(const data of this._dataList.values()){\n            data.destroy();\n        }\n\n        this._children = [];\n        this._dataList.clear();\n        this._valves.clear();\n        this._mirrors.clear();\n\n    };\n\n\n    destroy(){\n\n        this.clear();\n        this.parent = null;\n        this._dead = true;\n\n    };\n\n    createChild(name){\n\n        let child = new Scope(name);\n        child.parent = this;\n        return child;\n\n    };\n\n    insertParent(newParent){\n\n        newParent.parent = this.parent;\n        this.parent = newParent;\n        return this;\n\n    };\n\n    get parent() { return this._parent; };\n\n    set parent(newParent){\n\n        const oldParent = this.parent;\n\n        if(oldParent === newParent)\n            return;\n\n        if(oldParent) {\n            const i = oldParent._children.indexOf(this);\n            oldParent._children.splice(i, 1);\n        }\n\n        this._parent = newParent;\n\n        if(newParent) {\n            newParent._children.push(this);\n        }\n\n        return this;\n\n    };\n\n    set valves(list){\n\n        for(const name of list){\n            this._valves.set(name, true);\n        }\n\n    }\n\n    get valves(){ return Array.from(this._valves.keys());};\n\n\n    _createMirror(data){\n\n        const mirror = Object.create(data);\n        mirror._type = DATA_TYPES.MIRROR;\n        this._mirrors.set(data.name, mirror);\n        return mirror;\n\n    };\n\n    _createData(name, type){\n\n        const d = new Data(this, name, type);\n        this._dataList.set(name, d);\n        return d;\n\n    };\n\n\n    data(name){\n\n        return this.grab(name) || this._createData(name, DATA_TYPES.NONE);\n\n    };\n\n\n    action(name){\n\n        const d = this.grab(name);\n\n        if(d)\n            return d.verify(DATA_TYPES.ACTION);\n\n        return this._createData(name, DATA_TYPES.ACTION);\n\n    };\n\n\n    state(name){\n\n        const d = this.grab(name);\n\n        if(d)\n            return d.verify(DATA_TYPES.STATE);\n\n        const state = this._createData(name, DATA_TYPES.STATE);\n        this._createMirror(state);\n        return state;\n\n    };\n\n\n\n\n    findDataSet(names, required){\n\n\n        const result = {};\n        for(const name of names){\n            result[name] = this.find(name, required);\n        }\n\n        return result;\n\n    };\n\n    readDataSet(names, required){\n\n        const dataSet = this.findDataSet(names, required);\n        const result = {};\n\n        for(const d of dataSet) {\n            if (d) {\n                const lastPacket = d.peek();\n                if (lastPacket)\n                    result[d.name] = lastPacket.msg;\n            }\n        }\n\n        return result;\n    };\n\n\n    // created a flattened view of all data at and above this scope\n\n    flatten(){\n\n        let scope = this;\n\n        const result = new Map();\n        const appliedValves = new Map();\n\n        for(const [key, value] of scope._dataList){\n            result.set(key, value);\n        }\n\n        while(scope = scope._parent){\n\n            const dataList = scope._dataList;\n            const valves = scope._valves;\n            const mirrors = scope._mirrors;\n\n            if(!dataList.size)\n                continue;\n\n            // further restrict valves with each new scope\n\n            if(valves.size){\n                if(appliedValves.size) {\n                    for (const key of appliedValves.keys()) {\n                        if(!valves.has(key))\n                            appliedValves.delete(key);\n                    }\n                } else {\n                    for (const [key, value] of valves.entries()) {\n                        appliedValves.set(key, value);\n                    }\n                }\n            }\n\n            const possibles = appliedValves.size ? appliedValves : dataList;\n\n            for(const key of possibles.keys()) {\n                if (!result.has(key)) {\n\n                    const data = mirrors.get(key) || dataList.get(key);\n                    if (data)\n                        result.set(key, data);\n                }\n            }\n\n        }\n\n        return result;\n\n    };\n\n\n    find(name, required){\n\n        const localData = this.grab(name);\n        if(localData)\n            return localData;\n\n        let scope = this;\n\n        while(scope = scope._parent){\n\n            const valves = scope._valves;\n\n            // if valves exist and the name is not present, stop looking\n            if(valves.size && !valves.has(name)){\n                break;\n            }\n\n            const mirror = scope._mirrors.get(name);\n\n            if(mirror)\n                return mirror;\n\n            const d = scope.grab(name);\n\n            if(d)\n                return d;\n\n        }\n\n        if(required)\n            throw new Error('Required data: ' + name + ' not found!');\n\n        return null;\n\n    };\n\n    findOuter(name, required){\n\n        let foundInner = false;\n        const localData = this.grab(name);\n        if(localData)\n            foundInner = true;\n\n        let scope = this;\n\n        while(scope = scope._parent){\n\n            const valves = scope._valves;\n\n            // if valves exist and the name is not present, stop looking\n            if(valves.size && !valves.has(name)){\n                break;\n            }\n\n            const mirror = scope._mirrors.get(name);\n\n            if(mirror) {\n\n                if(foundInner)\n                    return mirror;\n\n                foundInner = true;\n                continue;\n            }\n\n            const d = scope.grab(name);\n\n            if(d) {\n\n                if(foundInner)\n                    return d;\n\n                foundInner = true;\n            }\n\n        }\n\n        if(required)\n            throw new Error('Required data: ' + name + ' not found!');\n\n        return null;\n\n    };\n\n    grab(name, required) {\n\n        const data = this._dataList.get(name);\n\n        if(!data && required)\n            throw new Error('Required Data: ' + name + ' not found!');\n\n        return data || null;\n\n    };\n\n    transaction(writes){\n\n        if(Array.isArray(writes))\n            return this._multiWriteArray(writes);\n        else if(typeof writes === 'object')\n            return this._multiWriteHash(writes);\n\n        throw new Error('Write values must be in an array of object hash.');\n\n    };\n\n    // write {name, topic, value} objects as a transaction\n    _multiWriteArray(writeArray, dimension){\n\n        const list = [];\n\n        for(const w of writeArray){\n            const d = this.find(w.name);\n            d.silentWrite(w.value, w.topic || null);\n            list.push(d);\n        }\n\n        let i = 0;\n        for(const d of list){\n            const w = writeArray[i];\n            d.refresh(w.topic || null);\n        }\n\n        return this;\n\n    };\n\n\n    // write key-values as a transaction\n    _multiWriteHash(writeHash){\n\n        const list = [];\n\n        for(const k in writeHash){\n            const v = writeHash[k];\n            const d = this.find(k);\n            d.silentWrite(v);\n            list.push(d);\n        }\n\n        for(const d of list){\n            d.refresh();\n        }\n\n        return this;\n\n    };\n\n}\n\nexport default Scope;\n","\nimport F from './flib.js';\n\nclass Pool {\n\n    constructor(stream){\n\n        this.stream = stream;\n\n        this.keep = null;\n        this.when = F.ALWAYS_TRUE;\n        this.until = F.ALWAYS_TRUE;\n        this.timer = null; // throttle, debounce, defer, batch, sync\n        this.clear = F.ALWAYS_FALSE;\n        this.isPrimed = false;\n        this.source = stream.name;\n\n    };\n\n    tell(msg, source) {\n\n        this.keep(msg, source);\n        if(!this.isPrimed){\n            const content = this.keep.content();\n            if(this.when(content)){\n                this.isPrimed = true;\n                this.timer(this);\n            }\n        }\n\n    };\n\n    build(prop, factory, ...args){\n        this[prop] = factory.call(this, ...args);\n    };\n\n    release(pool) {\n\n        pool = pool || this;\n        const hasContent = !pool.keep.isEmpty;\n        const msg = hasContent && pool.keep.next();\n\n        if(pool.clear()){\n            pool.keep.reset();\n            pool.when.reset();\n        }\n\n        pool.isPrimed = false;\n\n        if(hasContent)\n            pool.stream.emit(msg, pool.stream.name);\n\n    };\n\n}\n\n\n\nexport default Pool;","import Pool from './pool.js';\nimport F from './flib.js';\n\nclass Stream {\n\n    constructor(){\n\n        this.debugFrame = null;\n        this.dead = false;\n        this.children = [];\n        this.name = null;\n        this.pool = null;\n        this.cleanupMethod = F.NOOP; // to cleanup subscriptions\n        this.processMethod = this.emit;\n        this.actionMethod = null; // for run, transform, filter, name, delay\n\n    };\n\n    tell(msg, source) {\n\n        if(this.dead) // true if canceled or disposed midstream\n            return this;\n\n        this.processMethod(msg, source); // tell method = doDelay, doGroup, doHold, , doFilter\n\n        return this;\n\n    };\n\n    drop(stream){\n\n        const children = this.children;\n        const i = children.indexOf(stream);\n\n        if(i !== -1)\n            children.splice(i, 1);\n\n    };\n\n    addTarget(stream){\n        this.children.push(stream);\n    };\n\n    emit(msg, source, thisStream){\n\n        thisStream = thisStream || this; // allow callbacks with context instead of bind (massively faster)\n\n        const children = thisStream.children;\n        const len = children.length;\n\n        for(let i = 0; i < len; i++){\n            const c = children[i];\n            c.tell(msg, source);\n        }\n\n    };\n\n    doFilter(msg, source) {\n\n        if(!this.actionMethod(msg, source))\n            return;\n        this.emit(msg, source);\n\n    };\n\n\n    doTransform(msg, source) {\n\n        msg = this.actionMethod(msg, source);\n        this.emit(msg, source);\n\n    };\n\n    doDelay(msg, source) {\n\n        // todo add destroy -> kills timeout\n        // passes 'this' to avoid bind slowdown\n        setTimeout(this.emit, this.actionMethod(msg, source) || 0, msg, source, this);\n\n    };\n\n    doName(msg, source) {\n\n        source = this.actionMethod(msg, source);\n        this.emit(msg, source);\n\n    };\n\n\n    doRun(msg, source) {\n\n        this.actionMethod(msg, source);\n        this.emit(msg, source);\n\n    };\n\n    createPool(){\n\n        this.pool = new Pool(this);\n    };\n\n    doPool(msg, source) {\n\n        this.pool.tell(msg, source);\n\n    };\n\n    destroy(){\n\n        if(this.dead)\n            return;\n\n        this.cleanupMethod(); // should remove an eventListener if present\n\n    };\n\n}\n\n\n\nStream.fromData = function(data, topic, name){\n\n    const stream = new Stream();\n    const streamName = name || topic || data.name;\n    stream.name = streamName;\n\n    const toStream = function(msg){\n        stream.tell(msg, streamName);\n    };\n\n    stream.cleanupMethod = function(){\n        data.unsubscribe(toStream, topic);\n    };\n\n    data.follow(toStream, topic);\n\n    return stream;\n\n};\n\n\nStream.fromEvent = function(target, eventName, useCapture){\n\n    useCapture = !!useCapture;\n\n    const stream = new Stream();\n    stream.name = eventName;\n\n    const on = target.addEventListener || target.addListener || target.on;\n    const off = target.removeEventListener || target.removeListener || target.off;\n\n    const toStream = function(msg){\n        stream.tell(msg, eventName);\n    };\n\n    stream.cleanupMethod = function(){\n        off.call(target, eventName, toStream, useCapture);\n    };\n\n    on.call(target, eventName, toStream, useCapture);\n\n    return stream;\n\n};\n\n\nexport default Stream;","\nclass PoolAspects {\n\n    constructor() {\n\n        this.until      = null;\n        this.reduce     = null;\n        this.when       = null;\n        this.clear      = null;\n        this.timer      = null;\n\n    };\n\n}\n\nexport default PoolAspects;\n\n//\n// this._keep = null; // pool storage\n// this._until = null; // stream end lifecycle -- todo switch until to when in current setup\n// this._timer = null; // release from pool timer\n// this._clear = false; // condition to clear storage on release\n// this._when = false; // invokes timer for release\n","import F from './flib.js';\nimport PoolAspects from './poolAspects.js';\n\n\nclass Frame {\n\n    constructor(bus, streams) {\n\n        streams = streams || [];\n        this._bus = bus;\n        this._index = bus._frames.length;\n        this._holding = false; //begins group, keep, schedule frames\n        this._streams = streams;\n\n        this._process = null; // name of sync process method in streams\n        this._action = null; // function defining sync stream action\n        this._isFactory = false; // whether sync action is a stateful factory function\n\n        this._poolAspects = null;\n\n        const len = streams.length;\n        for(let i = 0; i < len; i++){\n            streams[i].debugFrame = this;\n        }\n\n    };\n\n    get bus() {\n        return this._bus;\n    };\n\n    get index() {\n        return this._index;\n    };\n\n    get holding() {\n        return this._holding;\n    };\n\n    get streams() {\n        return [].concat(this._streams);\n    }\n\n    applySyncProcess(name, action, isFactory){ // generate means action function must be called to generate stateful action\n\n        this._process = name;\n        this._action = action;\n        this._isFactory = isFactory;\n\n        const streams = this._streams;\n        const len = streams.length;\n\n        if(isFactory) {\n            for (let i = 0; i < len; i++) {\n                const s = streams[i];\n                s.actionMethod = action();\n                s.processMethod = s[name];\n            }\n        } else {\n            for (let i = 0; i < len; i++) {\n                const s = streams[i];\n                s.actionMethod = action;\n                s.processMethod = s[name];\n            }\n        }\n\n        return this;\n\n    };\n\n    hold(){\n\n        this._holding = true;\n        this._poolAspects = new PoolAspects();\n\n        const streams = this._streams;\n        const len = streams.length;\n\n        for(let i = 0; i < len; i++){\n            const s = streams[i];\n            s.createPool();\n            s.processMethod = s.doPool;\n        }\n\n        return this;\n\n    };\n\n    run(func, stateful){\n        return this.applySyncProcess('doRun', func, stateful);\n    };\n\n    transform(fAny, stateful){\n        return this.applySyncProcess('doTransform', F.FUNCTOR(fAny), stateful);\n    };\n\n    name(fStr, stateful){\n        return this.applySyncProcess('doName', F.FUNCTOR(fStr), stateful);\n    };\n\n    delay(fNum, stateful){\n        return this.applySyncProcess('doDelay', F.FUNCTOR(fNum), stateful);\n    };\n\n    filter(func, stateful){\n        return this.applySyncProcess('doFilter', func, stateful);\n    };\n\n    skipDupes() {\n        return this.applySyncProcess('doFilter', F.getSkipDupes, true);\n    };\n\n    clear(factory, ...args){\n        return this.buildPoolAspect('clear', factory, ...args);\n    };\n\n    // factory should define content and reset methods have signature f(msg, source) return f.content()\n\n    reduce(factory, ...args){\n        return this.buildPoolAspect('keep', factory, ...args);\n    };\n\n    timer(factory, ...args){\n        return this.buildPoolAspect('timer', factory, ...args);\n    };\n\n    when(factory, ...args){\n        return this.buildPoolAspect('when', factory, ...args);\n    };\n\n    until(factory, ...args){\n        return this.buildPoolAspect('until', factory, ...args);\n    };\n\n    buildPoolAspect(aspect, factory, ...args){\n\n        if(aspect === 'timer')\n            this._holding = false;\n\n        this._poolAspects[aspect] = [factory, ...args];\n\n        const streams = this._streams;\n        const len = streams.length;\n\n        for(let i = 0; i < len; i++){\n\n            const s = streams[i];\n            const pool = s.pool;\n            pool.build(aspect, factory, ...args);\n\n        }\n\n        return this;\n\n    };\n\n    destroy(){\n\n        const streams = this._streams;\n        const len = streams.length;\n        for(let i = 0; i < len; i++){\n            streams[i].cleanupMethod();\n        }\n        this._streams = null;\n\n    };\n    \n}\n\nexport default Frame;\n\n\n","\nimport Scope from './scope.js';\nimport Stream from './stream.js';\nimport Bus from './bus.js';\n\nconst Catbus = {};\nlet _batchQueue = [];\n\n\nCatbus.fromEvent = function(target, eventName, useCapture){\n\n    const stream = Stream.fromEvent(target, eventName, useCapture);\n    return new Bus([stream]);\n\n};\n\n\nCatbus.enqueue = function(pool){\n    _batchQueue.push(pool);\n};\n\nCatbus.scope = function(name){\n    console.log('root is ', name);\n    return new Scope(name);\n};\n\nCatbus.flush = function(){\n\n        let cycles = 0;\n        let q = _batchQueue;\n        _batchQueue = [];\n\n        while(q.length) {\n\n            while (q.length) {\n                const pool = q.shift();\n                pool.release();\n            }\n\n            q = _batchQueue;\n            _batchQueue = [];\n\n            cycles++;\n            if(cycles > 10)\n                throw new Error('Flush batch cycling loop > 10.', q);\n\n        }\n\n};\n\n\n\nexport default Catbus;\n"],"names":["isValid","type","reverseLookup","hasOwnProperty","ALWAYS_TRUE","ALWAYS_FALSE","TO_SOURCE","msg","source","TO_MSG","NOOP","FUNCTOR","val","_wireFrames","frame1","frame2","streams1","_streams","streams2","len","length","i","s1","s2","Stream","name","push","addTarget","Packet","topic","_msg","_topic","_source","_timestamp","Date","now","this","DATA_TYPES","p","v","SubscriberList","data","_subscribers","_lastPacket","_data","_name","_dead","silently","dead","currentPacket","ACTION","subscribers","concat","s","call","tell","watcher","indexOf","splice","Data","scope","NONE","Error","_scope","_type","_noTopicSubscriberList","_wildcardSubscriberList","_subscriberListsByTopic","Map","_throwDead","values","destroy","list","get","set","expectedType","subscribe","packet","peek","_demandSubscriberList","add","remove","subscriberList","lastPacket","undefined","write","MIRROR","read","idCounter","Scope","_id","_parent","_children","_dataList","_valves","_mirrors","clear","parent","child","newParent","mirror","Object","create","d","grab","_createData","verify","STATE","state","_createMirror","names","required","result","find","dataSet","findDataSet","appliedValves","key","value","dataList","valves","mirrors","size","keys","has","delete","entries","possibles","localData","foundInner","writes","Array","isArray","_multiWriteArray","_multiWriteHash","writeArray","dimension","w","silentWrite","refresh","writeHash","k","map","oldParent","from","Func","args","func","pool","enqueue","release","fNum","timedRelease","fromTimeout","stream","nowEmpty","keep","isEmpty","timeoutId","setTimeout","wasEmpty","msgDuringTimer","auto","n","Infinity","buffer","f","isBuffer","next","shift","content","seed","hasSeed","arguments","acc","initMsg","reset","groupBy","hash","g","last","firstMsg","latched","messages","keyHash","messagesByKey","hadMsg","lastMsg","diff","bus","holding","To_MSG","Pool","when","F","until","timer","isPrimed","prop","factory","hasContent","emit","debugFrame","children","cleanupMethod","processMethod","actionMethod","thisStream","fromData","streamName","toStream","unsubscribe","follow","fromEvent","target","eventName","useCapture","on","addEventListener","addListener","off","removeEventListener","removeListener","PoolAspects","reduce","Frame","streams","_bus","_index","_frames","_holding","_process","_action","_isFactory","_poolAspects","action","isFactory","createPool","doPool","stateful","applySyncProcess","fAny","fStr","getSkipDupes","buildPoolAspect","aspect","build","Bus","_currentFrame","lastFrame","nextFrame","mergedStream","ASSERT_NOT_HOLDING","fork","frame","addFrame","getDeferTimer","getBatchTimer","getSyncTimer","getThrottleTimer","hold","getScan","num","ASSERT_NEED_ONE_ARGUMENT","delay","ASSERT_IS_HOLDING","getAlwaysTrue","getWhenKeys","by","getGroup","getKeepAll","getKeepFirst","getKeepLast","ASSERT_IS_FUNCTION","run","mergeFrame","transform","filter","skipDupes","frames","Catbus","_batchQueue","log","flush","cycles","q"],"mappings":"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"}