{"version":3,"file":"catbus.umd.min.js","sources":["../src/flib.js","../src/dataTypes.js","../src/wave.js","../src/nyan.js","../src/nyanBus.js","../src/scope.js","../src/packet.js","../src/subscriberList.js","../src/data.js","../src/pool.js","../src/poolDef.js","../src/wire.js","../src/frame.js","../src/waveDef.js","../src/bus.js","../src/stream.js","../src/catbus.js"],"sourcesContent":["\nimport Catbus from './catbus.js';\n\nfunction ALWAYS_TRUE(){\n    return true;\n}\n\nfunction ALWAYS_FALSE(){\n    return false;\n}\n\n\nfunction TO_SOURCE(msg, source) {\n    return source;\n}\n\nfunction TO_TOPIC(msg, source, topic) {\n    return topic;\n}\n\nfunction TO_MSG(msg) {\n    return msg;\n}\n\nfunction NOOP(){\n\n}\n\n\nfunction FUNCTOR(val) {\n    return (typeof val === 'function') ? val : function() { return val; };\n}\n\nconst Func = {\n\n\n    ASSERT_NEED_ONE_ARGUMENT: function(args){\n        if(args.length < 1)\n            throw new Error('Method requires at least one argument.');\n    },\n\n    ASSERT_IS_FUNCTION: function(func){\n        if(typeof func !== 'function')\n            throw new Error('Argument [func] is not of type function.');\n    },\n\n    getAlwaysTrue: function(){\n       return function(){ return true;}\n    },\n\n    getBatchTimer: function(pool){\n\n            Catbus.enqueue(pool);\n\n    },\n\n    getSyncTimer: function(){\n        return function(pool) {\n            pool.release(pool);\n        }\n    },\n\n    getDeferTimer: function(){\n        return function(pool) {\n            setTimeout(pool.release, 0, pool);\n        }\n    },\n\n    getThrottleTimer: function(fNum){\n\n        const pool = this;\n        fNum = FUNCTOR(fNum);\n        let wasEmpty = false;\n        let timeoutId = null;\n        let msgDuringTimer = false;\n        const auto = pool.keep.auto;\n\n        function timedRelease(fromTimeout){\n\n            if(pool.stream.dead)\n                return;\n\n            const nowEmpty = pool.keep.isEmpty;\n\n            if(!fromTimeout){\n                if(!timeoutId) {\n                    pool.release(pool);\n                    wasEmpty = false;\n                    timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n                } else {\n                    msgDuringTimer = true;\n                }\n                return;\n            }\n\n            if(nowEmpty){\n                if(wasEmpty){\n                    // throttle becomes inactive\n                } else {\n                    // try one more time period to maintain throttle\n                    wasEmpty = true;\n                    msgDuringTimer = false;\n                    timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n                }\n            } else {\n                pool.release(pool);\n                wasEmpty = false;\n                timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n            }\n\n        }\n\n        return timedRelease;\n\n    },\n\n    getQueue: function(n){\n\n        n = n || Infinity;\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            if(buffer.length < n)\n                buffer.push(msg);\n            return buffer;\n        };\n\n        f.isBuffer = ALWAYS_TRUE;\n\n        f.next = function(){\n            return buffer.shift();\n        };\n\n        f.isEmpty = function(){\n            return buffer.length === 0;\n        };\n\n        f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getScan: function(func, seed){\n\n        const hasSeed = arguments.length === 2;\n        let acc;\n        let initMsg = true;\n\n        const f = function(msg, source){\n\n            if(initMsg){\n                initMsg = false;\n                if(hasSeed){\n                    acc = func(seed, msg, source);\n                } else {\n                    acc = msg;\n                }\n            } else {\n                acc = func(acc, msg, source);\n            }\n\n            return acc;\n\n        };\n\n        f.reset = NOOP;\n\n        f.next = f.content = function(){\n            return acc;\n        };\n\n\n        return f;\n    },\n\n    getGroup: function(groupBy){\n\n        groupBy = groupBy || TO_SOURCE;\n        const hash = {};\n\n        const f = function(msg, source){\n\n            const g = groupBy(msg, source);\n            if(g) {\n                hash[g] = msg;\n            } else { // no source, copy message props into hash to merge nameless streams of key data\n                for(const k in msg){\n                    hash[k] = msg[k];\n                }\n            }\n\n            return hash;\n\n        };\n\n        f.reset = function(){\n            for(const k in hash){\n                delete hash[k];\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return hash;\n        };\n\n        return f;\n\n    },\n\n    getHash: function(groupBy){\n\n        groupBy = groupBy || TO_SOURCE;\n        const hash = {};\n\n        const f = function(msg, source){\n\n            const g = groupBy(msg, source);\n            hash[g] = msg;\n            return hash;\n\n        };\n\n        f.reset = function(){\n            for(const k in hash){\n                delete hash[k];\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return hash;\n        };\n\n        return f;\n\n    },\n\n\n    getKeepLast: function(n){\n\n        if(!n || n < 0) {\n\n            let last;\n\n            const f = function(msg, source){\n                return last = msg;\n            };\n\n            f.reset = function(){\n                f.isEmpty = true;\n            };\n\n            f.next = f.content = function(){\n                return last;\n            };\n\n            return f;\n\n        }\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            buffer.push(msg);\n            if(buffer.length > n)\n                buffer.shift();\n            return buffer;\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n\n\n    getKeepFirst: function(n){\n\n        if(!n || n < 0) {\n\n            let firstMsg;\n            let hasFirst = false;\n            const f = function (msg, source) {\n                return hasFirst ? firstMsg : firstMsg = msg;\n            };\n\n            f.reset = function(){\n                firstMsg = false;\n                f.isEmpty = true;\n            };\n\n            f.next = f.content = function(){\n                return firstMsg;\n            };\n\n            return f;\n        }\n\n        const buffer = [];\n\n        const f = function(msg, source){\n\n            if(buffer.length < n)\n                buffer.push(msg);\n            return buffer;\n\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getKeepAll: function(){\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            buffer.push(msg);\n            return buffer;\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getWhenCount: function(n) {\n\n        let latched = false;\n\n        const f = function(messages){\n            latched = latched || messages.length >= n;\n            return latched;\n        };\n\n        f.reset = function(){\n            latched = false;\n        };\n\n        return f;\n\n    },\n\n    getWhenKeys: function(keys) {\n\n        const keyHash = {};\n        const len = keys.length;\n\n        for(let i = 0; i < len; i++){\n            const k = keys[i];\n            keyHash[k] = true;\n        }\n\n        let latched = false;\n\n        const f = function (messagesByKey) {\n\n            if(latched)\n                return true;\n\n            for (let i = 0; i < len; i++) {\n                const k = keys[i];\n                if (!messagesByKey.hasOwnProperty(k))\n                    return false;\n            }\n\n            return latched = true;\n\n        };\n\n        f.reset = function(){\n            latched = false;\n            for(const k in keyHash){\n                delete keyHash[k];\n            }\n        };\n\n        return f;\n\n    },\n\n    getHasKeys: function(keys, noLatch) {\n\n        let latched = false;\n        const len = keys.length;\n\n        return function (msg) {\n\n            if(latched || !len)\n                return true;\n\n            for(let i = 0; i < len; i++) {\n\n                const k = keys[i];\n                if(!msg.hasOwnProperty(k))\n                    return false;\n            }\n\n            if(!noLatch)\n                latched = true;\n\n            return true;\n\n        }\n\n    },\n\n\n    getSkipDupes: function() {\n\n        let hadMsg = false;\n        let lastMsg;\n\n        return function (msg) {\n\n            const diff = !hadMsg || msg !== lastMsg;\n            lastMsg = msg;\n            hadMsg = true;\n            return diff;\n\n        }\n\n    },\n\n\n    ASSERT_NOT_HOLDING: function(bus){\n        if(bus.holding)\n            throw new Error('Method cannot be invoked while holding messages in the frame.');\n    },\n\n    ASSERT_IS_HOLDING: function(bus){\n        if(!bus.holding)\n            throw new Error('Method cannot be invoked unless holding messages in the frame.');\n    }\n\n};\n\nFunc.TO_SOURCE = TO_SOURCE;\nFunc.TO_TOPIC = TO_TOPIC;\nFunc.To_MSG = TO_MSG;\nFunc.FUNCTOR = FUNCTOR;\nFunc.ALWAYS_TRUE = ALWAYS_TRUE;\nFunc.ALWAYS_FALSE = ALWAYS_FALSE;\nFunc.NOOP = NOOP;\n\nexport default Func;","\n\nconst DATA_TYPES = {\n\n    ACTION:   'action',\n    MIRROR:   'mirror',\n    STATE:    'state',\n    COMPUTED: 'computed',\n    NONE:     'none',\n    ANY:      'any'\n\n};\n\nconst reverseLookup = {};\n\nfor(const p in DATA_TYPES){\n    const v = DATA_TYPES[p];\n    reverseLookup[v] = p;\n}\n\nfunction isValid(type){\n    return reverseLookup.hasOwnProperty(type);\n}\n\n\nexport { DATA_TYPES, isValid};\n\n","\nfunction pass(frame, wire, msg, source, topic) {\n\n    frame.emit(wire, msg, source, topic);\n\n}\n\n\nclass Wave {\n\n    constructor(def){\n\n        this.process = (def && def.process) ? this[def.process] : pass;\n        this.action = def ? (def.stateful ? def.action(...def.args) : def.action) : null;\n\n    };\n\n    handle(frame, wire, msg, source, topic) {\n        this.process(frame, wire, msg, source, topic)\n    };\n\n    run(frame, wire, msg, source, topic) {\n\n        this.action(msg, source, topic);\n        frame.emit(wire, msg, source, topic);\n\n    };\n\n    msg(frame, wire, msg, source, topic) {\n\n        msg = this.action(msg, source, topic);\n        frame.emit(wire, msg, source, topic);\n\n    }\n\n    source(frame, wire, msg, source, topic) {\n\n        source = this.action(msg, source, topic);\n        frame.emit(wire, msg, source, topic);\n\n    }\n\n    filter(frame, wire, msg, source, topic) {\n\n        if(!this.action(msg, source, topic))\n            return;\n        frame.emit(wire, msg, source, topic);\n\n    };\n\n    delay(frame, wire, msg, source, topic) {\n\n        function callback(){\n            frame.emit(wire, msg, source, topic);\n        }\n\n        setTimeout(callback, this.action(msg, source, topic) || 0, msg, source, topic);\n\n    };\n\n}\n\n\nexport default Wave;","\n\nconst Nyan = {};\n\n// then = applies to all words in a phrase\n// watch: ^ = action, need, event, watch | read, must\n// then:  run, read, attr, and, style, write, blast, filter\n\nconst operationDefs = [\n\n    {name: 'ACTION', sym: '^',  react: true, subscribe: true, need: true, solo: true},\n    {name: 'WIRE',   sym: '~',  react: true, follow: true}, // INTERCEPT\n    {name: 'WATCH',  sym: null, react: true, follow: true},\n    {name: 'EVENT',  sym: '@',  react: true, event: true},\n    {name: 'ALIAS',  sym: '(',  then: true, solo: true},\n    {name: 'METHOD', sym: '`',  then: true, solo: true},\n    {name: 'READ',   sym: null, then: true, read: true},\n    {name: 'ATTR',   sym: '#',  then: true, solo: true, output: true},\n    {name: 'AND',    sym: '&',  then: true },\n    {name: 'STYLE',  sym: '$',  then: true,  solo: true, output: true },\n    {name: 'WRITE',  sym: '=',  then: true,  solo: true },\n    {name: 'SPRAY',  sym: '<',  then: true },\n    {name: 'RUN',    sym: '*',  then: true, output: true },\n    {name: 'FILTER', sym: '>',  then: true }\n\n];\n\n// cat, dog | & meow, kitten {*log} | =puppy\n\n\n// todo make ! a trailing thingie, must goes away\n// trailing defs -- ! = needs message in data to continue, ? = data must exist or throw error\n// {name: 'BEGIN',  sym: '{'}, -- fork\n// {name: 'END',    sym: '}'}, -- back\n// {name: 'PIPE',   sym: '|'}, -- phrase delimiter\n// read = SPACE\n// - is data maybe (data point might not be present)\n// ? is object maybe (object might not be there)\n// () is rename\n\nconst operationsBySymbol = {};\nconst operationsByName = {};\nconst symbolsByName = {};\nconst namesBySymbol = {};\nconst reactionsByName = {};\nconst withReactionsByName = {};\nconst thenByName = {};\n\nfor(let i = 0; i < operationDefs.length; i++){\n\n    const op = operationDefs[i];\n    const name = op.name;\n    const sym = op.sym;\n\n    if(sym) {\n        operationsBySymbol[sym] = op;\n        namesBySymbol[sym] = name;\n    }\n\n    operationsByName[name] = op;\n    symbolsByName[name] = sym;\n\n    if(op.then){\n        thenByName[name] = true;\n    }\n\n    if(op.react) {\n        reactionsByName[name] = true;\n        withReactionsByName[name] = true;\n    }\n\n}\n\n\n\nclass NyanWord {\n\n    constructor(name, operation, maybe, need, topic, alias, monitor, extracts){\n\n        this.name = name;\n        this.operation = operation;\n        this.maybe = maybe || false;\n        this.need = need || false;\n        this.topic = topic || null;\n        this.alias = alias || null;\n        this.monitor = monitor || false;\n        this.extracts = extracts && extracts.length ? extracts : null; // possible list of message property pulls\n        // this.useCapture =\n\n    }\n\n}\n\nlet tickStack = [];\n\nfunction toTickStackString(str){\n\n\n    tickStack = [];\n    const chunks = str.split(/([`])/);\n    const strStack = [];\n\n    let ticking = false;\n    while(chunks.length){\n        const c = chunks.shift();\n        if(c === '`'){\n            ticking = !ticking;\n            strStack.push(c);\n        } else {\n            if(ticking) {\n                tickStack.push(c);\n            } else {\n                strStack.push(c);\n            }\n        }\n    }\n\n    const result = strStack.join('');\n    //console.log('stack res', result, tickStack);\n    return result;\n}\n\nfunction parse(str, isProcess) {\n\n\n    str = toTickStackString(str);\n\n    const sentences = [];\n\n    // split on curlies and remove empty chunks (todo optimize for parsing speed, batch loop operations?)\n    let chunks = str.split(/([{}]|-})/).map(d => d.trim()).filter(d => d);\n\n    for(let i = 0; i < chunks.length; i++){\n\n        const chunk = chunks[i];\n        const sentence = (chunk === '}' || chunk === '{' || chunk === '-}') ? chunk : parseSentence(chunk);\n\n        if(typeof sentence === 'string' || sentence.length > 0)\n            sentences.push(sentence);\n\n    }\n\n    return validate(sentences, isProcess);\n\n\n}\n\nfunction validate(sentences, isProcess){\n\n    const cmdList = [];\n    let firstPhrase = true;\n    \n    for(let i = 0; i < sentences.length; i++){\n        const s = sentences[i];\n        if(typeof s !== 'string') {\n\n            for (let j = 0; j < s.length; j++) {\n                const phrase = s[j];\n                if(firstPhrase && !isProcess) {\n                    validateReactPhrase(phrase);\n                    firstPhrase = false;\n                    cmdList.push({name: 'REACT', phrase: phrase});\n                }\n                else {\n                    validateProcessPhrase(phrase);\n                    cmdList.push({name: 'PROCESS', phrase: phrase});\n                }\n            }\n\n        } else if (s === '{') {\n            cmdList.push({name: 'FORK'});\n        } else if (s === '}') {\n            cmdList.push({name: 'BACK'});\n        } else if (s === '-}') {\n            cmdList.push({name: 'JOIN'});\n        }\n    }\n\n    return cmdList;\n}\n\n\nfunction validateReactPhrase(phrase){\n\n    let hasReaction = false;\n    for(let i = 0; i < phrase.length; i++){\n\n        const nw = phrase[i];\n        const operation = nw.operation = nw.operation || 'WATCH';\n        hasReaction = hasReaction || reactionsByName[operation];\n        if(!withReactionsByName[operation])\n            throw new Error('This Nyan command cannot be in a reaction!');\n\n    }\n\n    if(!hasReaction)\n        throw new Error('Nyan commands must begin with an observation!');\n\n}\n\n\n\nfunction validateProcessPhrase(phrase){\n\n    const firstPhrase = phrase[0];\n    const firstOperation = firstPhrase.operation || 'READ';\n\n    if(!thenByName[firstOperation])\n        throw new Error('Illegal operation in phrase!'); // unknown or reactive\n\n    for(let i = 0; i < phrase.length; i++){\n\n        const nw = phrase[i];\n        nw.operation = nw.operation || firstOperation;\n        if(nw.operation !== firstOperation){\n\n           // console.log('mult', nw.operation, firstOperation);\n            throw new Error('Multiple operation types in phrase (only one allowed)!');\n\n        }\n\n    }\n\n}\n\n\n\nfunction parseSentence(str) {\n\n    const result = [];\n    const chunks = str.split('|').map(d => d.trim()).filter(d => d);\n\n    for(let i = 0; i < chunks.length; i++){\n\n        const chunk = chunks[i];\n        const phrase = parsePhrase(chunk);\n        result.push(phrase);\n\n    }\n\n    return result;\n\n}\n\nfunction parsePhrase(str) {\n\n    const words = [];\n    const rawWords = str.split(',').map(d => d.trim()).filter(d => d);\n\n    const len = rawWords.length;\n\n    for (let i = 0; i < len; i++) {\n\n        const rawWord = rawWords[i];\n        //console.log('word=', rawWord);\n        const rawChunks = rawWord.split(/([(?!:.`)])/);\n        const chunks = [];\n        let inMethod = false;\n\n        // white space is only allowed between e.g. `throttle 200`, `string meow in the hat`\n\n        while(rawChunks.length){\n            const next = rawChunks.shift();\n            if(next === '`'){\n                inMethod = !inMethod;\n                chunks.push(next);\n            } else {\n                if(!inMethod){\n                    const trimmed = next.trim();\n                    if(trimmed)\n                        chunks.push(trimmed);\n                } else {\n                    chunks.push(next);\n                }\n            }\n        }\n\n        //console.log('to:', chunks);\n        const nameAndOperation = chunks.shift();\n        const firstChar = rawWord[0];\n        const operation = namesBySymbol[firstChar];\n        const start = operation ? 1 : 0;\n        const name = nameAndOperation.slice(start).trim();\n        const extracts = [];\n\n        // todo hack (rename)\n\n        let maybe = false;\n        let monitor = false;\n        let topic = null;\n        let alias = null;\n        let need = false;\n\n        if(operation === 'ALIAS'){\n            alias = chunks.shift();\n            chunks.shift(); // todo verify ')'\n        } else if (operation === 'METHOD'){\n                chunks.shift();\n                // const next = chunks.shift();\n                const next = tickStack.shift();\n                const i = next.indexOf(' ');\n                if(i === -1) {\n                    extracts.push(next);\n                } else {\n                    extracts.push(next.slice(0, i));\n                    if(next.length > i){\n                        extracts.push(next.slice(i + 1));\n                    }\n                }\n\n            while(chunks.length){ chunks.shift(); }\n        }\n\n        while(chunks.length){\n\n            const c = chunks.shift();\n\n            switch(c){\n\n                case '.':\n\n                    const prop = chunks.length && chunks[0]; // todo assert not operation\n                    const silentFail = chunks.length > 1 && (chunks[1] === '?');\n\n                    if(prop) {\n                        extracts.push({name: prop, silentFail: silentFail});\n                        chunks.shift(); // remove word from queue\n                        if(silentFail)\n                            chunks.shift(); // remove ? from queue\n                    }\n\n                    break;\n\n                case '?':\n\n                    maybe = true;\n                    break;\n\n                case '!':\n\n                    need = true;\n                    break;\n\n                case ':':\n\n                    if(chunks.length){\n                        const next = chunks[0];\n                        if(next === '('){\n                            monitor = true;\n                        } else {\n                            topic = next;\n                            chunks.shift(); // remove topic from queue\n                        }\n                    } else {\n                        monitor = true;\n                    }\n\n                    break;\n\n                case '(':\n\n                    if(chunks.length){\n                        alias = chunks.shift(); // todo assert not operation\n                    }\n\n                    break;\n\n\n\n            }\n\n        }\n\n        alias = alias || topic || name;\n        const nw = new NyanWord(name, operation, maybe, need, topic, alias, monitor, extracts);\n        words.push(nw);\n\n    }\n\n    return words;\n\n}\n\nNyan.parse = parse;\n\n\nexport default Nyan;\n\n","import Wire from './wire.js';\nimport Nyan from './nyan.js';\n\n\nfunction getPacketFromDataWord(scope, word){\n\n    const data = scope.find(word.name, !word.maybe);\n    const peek = data && data.peek(word.topic);\n    return peek;\n\n}\n\n\nfunction getSurveyFromDataWord(scope, word){\n\n    const data = scope.find(word.name, !word.maybe);\n    return data && data.survey();\n\n}\n\nfunction throwError(msg){\n    console.log('throwing ', msg);\n    const e = new Error(msg);\n    console.log(this, e);\n    throw e;\n}\n\nfunction getDoSkipNamedDupes(names){\n\n    let lastMsg = {};\n    const len = names.length;\n\n    return function doSkipNamedDupes(msg) {\n\n        let diff = false;\n        for(let i = 0; i < len; i++){\n            const name = names[i];\n            if(!lastMsg.hasOwnProperty(name) || lastMsg[name] !== msg[name])\n                diff = true;\n            lastMsg[name] = msg[name];\n        }\n\n        return diff;\n\n    };\n}\n\n\nfunction getDoWrite(scope, word){\n\n    const data = scope.find(word.name, !word.maybe);\n\n    return function doWrite(msg) {\n        data.write(msg, word.topic);\n    };\n\n}\n\n\nfunction getDoSpray(scope, phrase){\n\n    const wordByAlias = {};\n    const dataByAlias = {};\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++){ // todo, validate no dupe alias in word validator for spray\n\n        const word = phrase[i];\n        const data = scope.find(word.name, !word.maybe);\n        if(data) { // might not exist if optional\n            wordByAlias[word.alias] = word;\n            dataByAlias[word.alias] = data;\n        }\n\n    }\n\n    return function doWrite(msg) {\n\n        for(const alias in msg){\n\n            const data = dataByAlias[alias];\n            if(data) {\n                const word = wordByAlias[alias];\n                const msgPart = msg[alias];\n                data.silentWrite(msgPart, word.topic);\n            }\n\n        }\n\n        for(const alias in msg){\n\n            const data = dataByAlias[alias];\n            if(data) {\n                const word = wordByAlias[alias];\n                data.refresh(word.topic);\n            }\n\n        }\n\n\n    };\n\n\n}\n\n\nfunction getDoRead(scope, phrase){\n\n    const len = phrase.length;\n    const firstWord = phrase[0];\n\n    if(len > 1 || firstWord.monitor) { // if only reading word is a wildcard subscription then hash as well\n        return getDoReadMultiple(scope, phrase);\n    } else {\n        return getDoReadSingle(scope, firstWord);\n    }\n\n}\n\n\nfunction getDoAnd(scope, phrase) {\n\n    return getDoReadMultiple(scope, phrase, true);\n\n}\n\n\nfunction getDoReadSingle(scope, word) {\n\n    return function doReadSingle() {\n\n        const packet = getPacketFromDataWord(scope, word);\n        return packet && packet.msg;\n\n    };\n\n}\n\n\nfunction getDoReadMultiple(scope, phrase, isAndOperation){\n\n\n        const len = phrase.length;\n\n\n        return function doReadMultiple(msg, source) {\n\n            const result = {};\n\n            if(isAndOperation){\n\n                if(source){\n                    result[source] = msg;\n                } else {\n                    for (const p in msg) {\n                        result[p] = msg[p];\n                    }\n                }\n            }\n\n            for (let i = 0; i < len; i++) {\n                const word = phrase[i];\n\n                if(word.monitor){\n\n                    const survey = getSurveyFromDataWord(scope, word);\n                    for(const [key, value] of survey){\n                        result[key] = value;\n                    }\n\n                } else {\n\n                    const packet = getPacketFromDataWord(scope, word);\n                    const prop = word.monitor ? (word.alias || word.topic) : (word.alias || word.name);\n                    if (packet)\n                        result[prop] = packet.msg;\n\n                }\n\n            }\n\n            return result;\n\n        };\n\n}\n\n\n// get data stream -- store data in bus, emit into stream on pull()\n\n\nfunction getDataWire(scope, word, canPull) {\n\n    const data = scope.find(word.name, !word.maybe);\n    if(word.monitor){\n        return Wire.fromMonitor(data, word.alias, canPull);\n    } else {\n        return Wire.fromSubscribe(data, word.topic, word.alias, canPull);\n    }\n\n}\n\nfunction isObject(v) {\n    if (v === null)\n        return false;\n    return (typeof v === 'function') || (typeof v === 'object');\n}\n\n\nfunction getEventWire(word, target){\n\n    return Wire.fromEvent(target, word.topic, word.useCapture, word.alias);\n\n}\n\nfunction doExtracts(value, extracts) {\n\n    let result = value;\n    const len = extracts.length;\n\n    for (let i = 0; i < len; i++) {\n        const extract = extracts[i];\n        if(!isObject(result)) {\n            if(extract.silentFail)\n                return undefined;\n\n            throwError('Cannot access property \\'' + extract.name + '\\' of ' + result);\n\n        }\n        result = result[extract.name];\n    }\n\n\n    return result;\n\n}\n\nfunction getNeedsArray(phrase){\n    return phrase.filter(word => word.operation.need).map(word => word.alias);\n}\n\nfunction getDoMsgHashExtract(words) {\n\n    const len = words.length;\n    const extractsByAlias = {};\n\n    for (let i = 0; i < len; i++) {\n\n        const word = words[i];\n        extractsByAlias[word.alias] = word.extracts;\n\n    }\n\n    return function(msg) {\n\n        const result = {};\n        for(const alias in extractsByAlias){\n            const hasProp = msg.hasOwnProperty(alias);\n            if(hasProp){\n                result[alias] = doExtracts(msg[alias], extractsByAlias[alias]);\n            }\n        }\n\n        return result;\n\n    };\n\n}\n\nfunction getDoMsgExtract(word) {\n\n    const extracts = word.extracts;\n\n    return function(msg){\n        return doExtracts(msg, extracts);\n    }\n\n}\n\n\nfunction applyReaction(scope, bus, phrase, target) { // target is some event emitter\n\n    const need = [];\n    const skipDupes = [];\n    const streams = [];\n    const extracts = [];\n\n    if(phrase.length === 1 && phrase[0].operation === 'ACTION'){\n        const word = phrase[0];\n        bus.wire(getDataWire(scope, word, false));\n        return;\n    }\n\n    for(let i = 0; i < phrase.length; i++){\n\n        const word = phrase[i];\n        const operation = word.operation;\n\n        if(operation === 'WATCH') {\n            bus.wire(getDataWire(scope, word, true));\n            skipDupes.push(word.alias)\n        }\n        else if(operation === 'WIRE'){\n            bus.wire(getDataWire(scope, word, true));\n        }\n        else if(operation === 'EVENT') {\n            bus.wire(getEventWire(word, target));\n        }\n\n        if(word.extracts)\n            extracts.push(word);\n\n        if(word.need)\n            need.push(word.alias);\n\n    }\n\n    if(bus._wires.length > 1) {\n\n        bus.merge().group().batch();\n\n        if(extracts.length)\n            bus.msg(getDoMsgHashExtract(extracts));\n\n        if(need.length)\n            bus.hasKeys(need);\n\n        if(skipDupes.length){\n            bus.filter(getDoSkipNamedDupes(skipDupes));\n        }\n\n    } else {\n\n        if(extracts.length)\n            bus.msg(getDoMsgExtract(extracts[0]));\n\n        if(skipDupes.length)\n            bus.skipDupes();\n\n    }\n\n}\n\nfunction isTruthy(msg){ return !!msg; };\nfunction isFalsey(msg){ return !msg; };\n\n\nfunction applyMethod(bus, word) {\n\n    const method = word.extracts[0];\n\n    switch(method){\n\n        case 'true':\n            bus.msg(true);\n            break;\n\n        case 'false':\n            bus.msg(false);\n            break;\n\n        case 'null':\n            bus.msg(null);\n            break;\n\n        case 'undefined':\n            bus.msg(undefined);\n            break;\n\n        case 'array':\n            bus.msg([]);\n            break;\n\n        case 'object':\n            bus.msg({});\n            break;\n\n        case 'truthy':\n            bus.filter(isTruthy);\n            break;\n\n        case 'falsey':\n            bus.filter(isFalsey);\n            break;\n\n        case 'string':\n            bus.msg(function(){ return word.extracts[1];});\n            break;\n\n            // throttle x, debounce x, delay x, last x, first x, all\n\n    }\n\n}\n\nfunction applyProcess(scope, bus, phrase, context, node) {\n\n    const operation = phrase[0].operation; // same for all words in a process phrase\n\n    if(operation === 'READ') {\n        bus.msg(getDoRead(scope, phrase));\n        const needs = getNeedsArray(phrase);\n        if(needs.length)\n            bus.whenKeys(needs);\n    } else if (operation === 'AND') {\n        bus.msg(getDoAnd(scope, phrase));\n        const needs = getNeedsArray(phrase);\n        if (needs.length)\n            bus.whenKeys(needs);\n    } else if (operation === 'METHOD') {\n        applyMethod(bus, phrase[0]);\n    } else if (operation === 'FILTER') {\n        applyFilterProcess(bus, phrase, context);\n    } else if (operation === 'RUN') {\n        applyMsgProcess(bus, phrase, context);\n    } else if (operation === 'ALIAS') {\n        applySourceProcess(bus, phrase[0]);\n    } else if (operation === 'WRITE') {\n        bus.run(getDoWrite(scope, phrase[0]));\n    } else if (operation === 'SPRAY') {\n        bus.run(getDoSpray(scope, phrase)); // todo validate that writes do not contain words in reacts\n\n    }\n\n}\n\n\n\nfunction applyMsgProcess(bus, phrase, context){\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++) {\n\n        const word = phrase[i];\n        const name = word.name;\n        const method = context[name];\n\n        const f = function (msg, source, topic) {\n            return method.call(context, msg, source, topic);\n        };\n\n        bus.msg(f);\n\n    }\n\n}\n\n\nfunction applyRunProcess(bus, phrase, context){\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++) {\n\n        const word = phrase[i];\n        const name = word.name;\n        const method = context[name];\n\n        const f = function (msg, source, topic) {\n            return method.call(context, msg, source, topic);\n        };\n\n        bus.run(f);\n\n    }\n\n}\n\nfunction applySourceProcess(bus, word){\n\n    bus.source(word.alias);\n\n}\n\n\nfunction applyFilterProcess(bus, phrase, context){\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++) {\n\n        const word = phrase[i];\n        const name = word.name;\n        const method = context[name];\n\n        const f = function (msg, source, topic) {\n            return method.call(context, msg, source, topic);\n        };\n\n        bus.filter(f);\n\n    }\n\n}\n\n\nfunction nyanToBus(scope, bus, str, context, target){\n\n    const nyan = Nyan.parse(str);\n    const len = nyan.length;\n\n    for(let i = 0; i < len; i++){\n\n        const cmd = nyan[i];\n        const name = cmd.name;\n        const phrase = cmd.phrase;\n\n      //  console.log('----', name, phrase);\n\n        if(name === 'JOIN') {\n            bus = bus.join();\n            bus.merge();\n            bus.group();\n            bus.sync();\n        } else if(name === 'FORK'){\n            bus = bus.fork();\n        } else if (name === 'BACK'){\n            bus = bus.back();\n        } else {\n\n            if(name === 'PROCESS')\n                applyProcess(scope, bus, phrase, context, target);\n            else // name === 'REACT'\n                applyReaction(scope, bus, phrase, target);\n\n        }\n    }\n\n    return bus;\n\n}\n\nexport default nyanToBus;","\nimport F from './flib.js';\nimport Data from './data.js';\nimport { DATA_TYPES, isValid } from './dataTypes.js';\nimport Bus from './bus.js';\nimport Nyan from './nyan.js';\nimport Stream from './stream.js';\nimport nyanToBus from './nyanBus.js';\n\nlet idCounter = 0;\n\nfunction _destroyEach(arr){\n\n    const len = arr.length;\n    for(let i = 0; i < len; i++){\n        const item = arr[i];\n        item.destroy();\n    }\n\n}\n\n\nclass Scope{\n\n    constructor(name) {\n\n        this._id = ++idCounter;\n        this._name = name;\n        this._parent = null;\n        this._children = [];\n        this._busList = [];\n        this._dataList = new Map();\n        this._valves = new Map();\n        this._mirrors = new Map();\n        this._dead = false;\n\n    };\n\n    get name() { return this._name; };\n    get dead() { return this._dead; };\n\n    get children(){\n\n        return this._children.map((d) => d);\n\n    };\n\n\n    // todo react via nyan (so it can be precompiled and reused\n    react(str, context, node){ // string is Nyan\n\n        if(!str)\n            throw new Error('Need a Nyan phrase!');\n\n        let b = new Bus(this);\n\n        return nyanToBus(this, b, str, context, node);\n\n    };\n\n    clear(){\n\n        if(this._dead)\n            return;\n\n        _destroyEach(this.children); // iterates over copy to avoid losing position as children leaves their parent\n        _destroyEach(this._busList);\n        _destroyEach(this._dataList.values());\n\n        this._children = [];\n        this._busList = [];\n        this._dataList.clear();\n        this._valves.clear();\n        this._mirrors.clear();\n\n    };\n\n    destroy(){\n\n        this.clear();\n        this.parent = null;\n        this._dead = true;\n\n    };\n\n    createChild(name){\n\n        let child = new Scope(name);\n        child.parent = this;\n        return child;\n\n    };\n\n    insertParent(newParent){\n\n        newParent.parent = this.parent;\n        this.parent = newParent;\n        return this;\n\n    };\n\n    get parent() { return this._parent; };\n\n    set parent(newParent){\n\n        const oldParent = this.parent;\n\n        if(oldParent === newParent)\n            return;\n\n        if(oldParent) {\n            const i = oldParent._children.indexOf(this);\n            oldParent._children.splice(i, 1);\n        }\n\n        this._parent = newParent;\n\n        if(newParent) {\n            newParent._children.push(this);\n        }\n\n        return this;\n\n    };\n\n    set valves(list){\n\n        for(const name of list){\n            this._valves.set(name, true);\n        }\n\n    }\n\n    get valves(){ return Array.from(this._valves.keys());};\n\n\n    _createMirror(data){\n\n        const mirror = Object.create(data);\n        mirror._type = DATA_TYPES.MIRROR;\n        this._mirrors.set(data.name, mirror);\n        return mirror;\n\n    };\n\n    _createData(name, type){\n\n        const d = new Data(this, name, type);\n        this._dataList.set(name, d);\n        return d;\n\n    };\n\n\n    data(name){\n\n        return this.grab(name) || this._createData(name, DATA_TYPES.NONE);\n\n    };\n\n\n    action(name){\n\n        const d = this.grab(name);\n\n        if(d)\n            return d.verify(DATA_TYPES.ACTION);\n\n        return this._createData(name, DATA_TYPES.ACTION);\n\n    };\n\n\n    state(name){\n\n        const d = this.grab(name);\n\n        if(d)\n            return d.verify(DATA_TYPES.STATE);\n\n        const state = this._createData(name, DATA_TYPES.STATE);\n        this._createMirror(state);\n        return state;\n\n    };\n\n\n    findDataSet(names, required){\n\n\n        const result = {};\n        for(const name of names){\n            result[name] = this.find(name, required);\n        }\n\n        return result;\n\n    };\n\n    readDataSet(names, required){\n\n        const dataSet = this.findDataSet(names, required);\n        const result = {};\n\n        for(const d of dataSet) {\n            if (d) {\n                const lastPacket = d.peek();\n                if (lastPacket)\n                    result[d.name] = lastPacket.msg;\n            }\n        }\n\n        return result;\n    };\n\n\n    // created a flattened view of all data at and above this scope\n\n    flatten(){\n\n        let scope = this;\n\n        const result = new Map();\n        const appliedValves = new Map();\n\n        for(const [key, value] of scope._dataList){\n            result.set(key, value);\n        }\n\n        while(scope = scope._parent){\n\n            const dataList = scope._dataList;\n            const valves = scope._valves;\n            const mirrors = scope._mirrors;\n\n            if(!dataList.size)\n                continue;\n\n            // further restrict valves with each new scope\n\n            if(valves.size){\n                if(appliedValves.size) {\n                    for (const key of appliedValves.keys()) {\n                        if(!valves.has(key))\n                            appliedValves.delete(key);\n                    }\n                } else {\n                    for (const [key, value] of valves.entries()) {\n                        appliedValves.set(key, value);\n                    }\n                }\n            }\n\n            const possibles = appliedValves.size ? appliedValves : dataList;\n\n            for(const key of possibles.keys()) {\n                if (!result.has(key)) {\n\n                    const data = mirrors.get(key) || dataList.get(key);\n                    if (data)\n                        result.set(key, data);\n                }\n            }\n\n        }\n\n        return result;\n\n    };\n\n\n    find(name, required){\n\n        const localData = this.grab(name);\n        if(localData)\n            return localData;\n\n        let scope = this;\n\n        while(scope = scope._parent){\n\n            const valves = scope._valves;\n\n            // if valves exist and the name is not present, stop looking\n            if(valves.size && !valves.has(name)){\n                break;\n            }\n\n            const mirror = scope._mirrors.get(name);\n\n            if(mirror)\n                return mirror;\n\n            const d = scope.grab(name);\n\n            if(d)\n                return d;\n\n        }\n\n        if(required)\n            throw new Error('Required data: ' + name + ' not found!');\n\n        return null;\n\n    };\n\n    findOuter(name, required){\n\n        let foundInner = false;\n        const localData = this.grab(name);\n        if(localData)\n            foundInner = true;\n\n        let scope = this;\n\n        while(scope = scope._parent){\n\n            const valves = scope._valves;\n\n            // if valves exist and the name is not present, stop looking\n            if(valves.size && !valves.has(name)){\n                break;\n            }\n\n            const mirror = scope._mirrors.get(name);\n\n            if(mirror) {\n\n                if(foundInner)\n                    return mirror;\n\n                foundInner = true;\n                continue;\n            }\n\n            const d = scope.grab(name);\n\n            if(d) {\n\n                if(foundInner)\n                    return d;\n\n                foundInner = true;\n            }\n\n        }\n\n        if(required)\n            throw new Error('Required data: ' + name + ' not found!');\n\n        return null;\n\n    };\n\n    grab(name, required) {\n\n        const data = this._dataList.get(name);\n\n        if(!data && required)\n            throw new Error('Required Data: ' + name + ' not found!');\n\n        return data || null;\n\n    };\n\n    transaction(writes){\n\n        if(Array.isArray(writes))\n            return this._multiWriteArray(writes);\n        else if(typeof writes === 'object')\n            return this._multiWriteHash(writes);\n\n        throw new Error('Write values must be in an array of object hash.');\n\n    };\n\n    // write {name, topic, value} objects as a transaction\n    _multiWriteArray(writeArray){\n\n        const list = [];\n\n        for(const w of writeArray){\n            const d = this.find(w.name);\n            d.silentWrite(w.value, w.topic);\n            list.push(d);\n        }\n\n        let i = 0;\n        for(const d of list){\n            const w = writeArray[i];\n            d.refresh(w.topic);\n        }\n\n        return this;\n\n    };\n\n\n    // write key-values as a transaction\n    _multiWriteHash(writeHash){\n\n        const list = [];\n\n        for(const k in writeHash){\n            const v = writeHash[k];\n            const d = this.find(k);\n            d.silentWrite(v);\n            list.push(d);\n        }\n\n        for(const d of list){\n            d.refresh();\n        }\n\n        return this;\n\n    };\n\n}\n\nexport default Scope;\n","\nclass Packet {\n\n    constructor(msg, topic, source) {\n        this._msg       = msg;\n        this._topic     = topic;\n        this._source    = source;\n        this._timestamp = Date.now();\n    };\n\n    get msg() { return this._msg; };\n    get topic() { return this._topic; };\n    get source() { return this._source; };\n    get timestamp() { return this._timestamp; };\n\n}\n\nexport default Packet;","\nimport Packet from './packet.js';\nimport { DATA_TYPES } from './dataTypes';\n\nclass SubscriberList {\n\n    constructor(topic, data) {\n\n        this._topic = topic;\n        this._subscribers = [];\n        this._lastPacket = null;\n        this._data = data;\n        this._name = data._name;\n        this._dead = false;\n\n    };\n\n    get lastPacket() { return this._lastPacket; };\n    get data() { return this._data; };\n    get name() { return this._name; };\n    get dead() { return this._dead; };\n    get topic() { return this._topic; };\n\n    handle(msg, topic, silently){\n\n        if(this.dead)\n            return;\n\n        topic = topic || this.topic;\n        let source = this.name;\n        let currentPacket = new Packet(msg, topic, source);\n\n        if(this.data.type !== DATA_TYPES.ACTION) // actions do not store data (ephemeral and immediate)\n            this._lastPacket = currentPacket;\n\n        let subscribers = [].concat(this._subscribers); // call original sensors in case subscriptions change mid loop\n        let len = subscribers.length;\n\n        if(!silently) {\n            for (let i = 0; i < len; i++) {\n                let s = subscribers[i];\n                typeof s === 'function' ? s.call(s, msg, currentPacket) : s.handle(msg, currentPacket);\n            }\n        }\n\n    };\n\n    destroy(){\n\n        if(this.dead)\n            return;\n\n        this._subscribers = null;\n        this._lastPacket = null;\n        this._dead = true;\n\n    };\n\n    add(watcher){\n\n        this._subscribers.push(watcher);\n\n    };\n\n    remove(watcher){\n\n        let i = this._subscribers.indexOf(watcher);\n\n        if(i !== -1)\n            this._subscribers.splice(i, 1);\n\n    };\n\n}\n\n\nexport default SubscriberList;\n\n","\nimport SubscriberList from './subscriberList.js';\nimport {isValid, DATA_TYPES} from './dataTypes.js';\n\nconst NO_TOPIC = '___NO_TOPIC___';\n\nclass Data {\n\n    constructor(scope, name, type) {\n\n        type = type || DATA_TYPES.NONE;\n\n        if(!isValid(type))\n            throw new Error('Invalid Data of type: ' + type);\n\n        this._scope      = scope;\n        this._name       = name;\n        this._type       = type;\n        this._dead       = false;\n\n        this._wildcardSubscriberList = new SubscriberList(null, this);\n        this._subscriberListsByTopic = new Map();\n\n    };\n\n    get scope() { return this._scope; };\n    get name() { return this._name; };\n    get type() { return this._type; };\n    get dead() { return this._dead; };\n\n    destroy(){\n\n        if(this.dead)\n            this._throwDead();\n        \n        for(const list of this._subscriberListsByTopic.values()){\n            list.destroy();\n        }\n\n        this._dead = true;\n\n    };\n    \n    _demandSubscriberList(topic){\n\n        topic = topic || undefined;\n        let list = this._subscriberListsByTopic.get(topic);\n\n        if(list)\n            return list;\n\n        list = new SubscriberList(topic, this);\n        this._subscriberListsByTopic.set(topic, list);\n\n        return list;\n        \n    };\n\n    verify(expectedType){\n\n        if(this.type === expectedType)\n            return this;\n\n        throw new Error('Data ' + this.name + ' requested as type ' + expectedType + ' exists as ' + this.type);\n\n    };\n\n    follow(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.subscribe(watcher, topic);\n        let packet = this.peek();\n\n        if(packet)\n            typeof watcher === 'function' ? watcher.call(watcher, packet.msg, packet) : watcher.handle(packet.msg, packet);\n\n        return this;\n\n    };\n\n    subscribe(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this._demandSubscriberList(topic).add(watcher);\n\n        return this;\n\n    };\n\n    monitor(watcher){\n\n        if(this.dead)\n            this._throwDead();\n\n        this._wildcardSubscriberList.add(watcher);\n\n        return this;\n\n    };\n\n    unsubscribe(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this._demandSubscriberList(topic).remove(watcher);\n        this._wildcardSubscriberList.remove(watcher);\n\n        return this;\n\n    };\n\n    topics(){\n\n        return this._subscriberListsByTopic.keys();\n\n    };\n\n    survey(){ // get entire key/value store by topic:lastPacket\n\n        const entries = this._subscriberListsByTopic.entries();\n        const m = new Map();\n        for (const [key, value] of entries) {\n            m.set(key, value.lastPacket);\n        }\n\n        return m;\n    };\n\n\n    peek(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        const subscriberList = this._subscriberListsByTopic.get(topic);\n        return subscriberList ? subscriberList.lastPacket : null;\n\n    };\n\n\n    read(topic) {\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        let packet = this.peek(topic);\n        return (packet) ? packet.msg : undefined;\n\n    };\n\n\n    silentWrite(msg, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.write(msg, topic, true);\n\n    };\n\n\n    write(msg, topic, silently){\n\n        if(this.dead)\n            this._throwDead();\n\n        if(this.type === DATA_TYPES.MIRROR)\n            throw new Error('Mirror Data: ' + this.name + ' is read-only');\n\n        topic = topic || undefined;\n        const list = this._demandSubscriberList(topic);\n        list.handle(msg, topic, silently);\n        this._wildcardSubscriberList.handle(msg, topic, silently);\n\n    };\n\n\n    refresh(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        const lastPacket = this.peek(topic);\n\n        if(lastPacket)\n            this.write(lastPacket._msg, topic);\n\n        return this;\n\n    };\n\n\n    toggle(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.write(!this.read(topic), topic);\n\n        return this;\n\n    };\n\n    _throwDead(){\n\n        throw new Error('Data: ' + this.name + ' is already dead.');\n\n    };\n\n}\n\nexport default Data;\n\n\n\n\n\n\n\n\n\n\n\n\n","\nimport F from './flib.js';\n\nclass Pool {\n\n    constructor(frame, wire, def){\n\n        this.frame = frame;\n        this.wire = wire;\n\n        function fromDef(name){\n\n            if(!def[name])\n                return null;\n\n            const [factory, stateful, ...args] = def[name];\n\n            return stateful ? factory.call(this, ...args) : factory;\n\n        }\n\n        this.keep = fromDef('keep') || F.getKeepLast();\n        this.when = fromDef('when') || F.ALWAYS_TRUE;\n        this.until = fromDef('until') || F.ALWAYS_TRUE;\n        this.timer = fromDef('timer');  // throttle, debounce, defer, batch, sync\n        this.clear = fromDef('clear') || F.ALWAYS_FALSE;\n\n        this.isPrimed = false;\n\n\n    };\n\n    handle(frame, wire, msg, source, topic) {\n\n        this.keep(msg, source, topic);\n        if(!this.isPrimed){\n            const content = this.keep.content();\n            if(this.when(content)){\n                this.isPrimed = true;\n                this.timer(this);\n            }\n        }\n\n    };\n\n    build(prop, factory, ...args){\n        this[prop] = factory.call(this, ...args);\n    };\n\n    release(pool) {\n\n        pool = pool || this;\n        const hasContent = !pool.keep.isEmpty;\n        const msg = hasContent && pool.keep.next();\n\n        if(pool.clear()){\n            pool.keep.reset();\n            pool.when.reset();\n        }\n\n        pool.isPrimed = false;\n\n        if(hasContent)\n            pool.frame.emit(pool.wire, msg);\n\n    };\n\n}\n\n\nexport default Pool;","\nclass PoolDef {\n\n    constructor(){\n\n        this.name = 'pool';\n        this.keep  = null;\n        this.when  = null;\n        this.until = null;\n        this.timer = null;\n        this.clear = null;\n\n    };\n\n}\n\n\nexport default PoolDef;","import F from './flib.js';\n\nclass Wire {\n\n    constructor(){\n\n        this.target = null; // a frame in a bus\n        this.dead = false;\n        this.name = null;\n        this.cleanupMethod = F.NOOP; // to cleanup subscriptions\n        this.pull = F.NOOP; // to retrieve and emit stored values from a source\n\n    };\n\n    handle(msg, source, topic) {\n\n        if(!this.dead && this.target)\n            this.target.handle(this, msg, this.name || source, topic);\n\n        return this;\n\n    };\n\n    destroy(){\n\n        if(!this.dead && this.target){\n            this.dead = true;\n            this.cleanupMethod();\n        }\n\n    };\n\n}\n\n\n\nWire.fromMonitor = function(data, name){\n\n    const wire = new Wire();\n    const wireName = wire.name = name || data.name;\n\n    const toWire = function(msg, source, topic){\n        wire.handle(msg, wireName, topic);\n    };\n\n    wire.cleanupMethod = function(){\n        data.unsubscribe(toWire);\n    };\n\n    data.monitor(toWire);\n\n    return wire;\n\n};\n\n\n\nWire.fromSubscribe = function(data, topic, name, canPull){\n\n    const wire = new Wire();\n    const wireName = wire.name = name || topic || data.name;\n\n    const toWire = function(msg, source, topic){\n        wire.handle(msg, wireName, topic);\n    };\n\n    wire.cleanupMethod = function(){\n        data.unsubscribe(toWire, topic);\n    };\n\n    if(canPull){\n        wire.pull = function(){\n            const packet = data.peek();\n            if(packet) {\n                const msg = packet._msg;\n                const source = wireName || packet._source;\n                const topic = packet._topic;\n                wire.handle(msg, source, topic);\n            }\n        }\n    }\n\n    data.subscribe(toWire, topic);\n\n    return wire;\n\n};\n\n\n\nWire.fromEvent = function(target, eventName, useCapture){\n\n    useCapture = !!useCapture;\n\n    const wire = new Wire();\n    wire.name = eventName;\n\n    const on = target.addEventListener || target.addListener || target.on;\n    const off = target.removeEventListener || target.removeListener || target.off;\n\n    const toWire = function(msg){\n        wire.handle(msg, eventName);\n    };\n\n    wire.cleanupMethod = function(){\n        off.call(target, eventName, toWire, useCapture);\n    };\n\n    on.call(target, eventName, toWire, useCapture);\n\n    return wire;\n\n};\n\n\nexport default Wire;","\nimport Wave from './wave.js';\nimport Pool from './pool.js';\nimport PoolDef from './poolDef.js';\nimport Wire from './wire.js';\n\nclass Frame {\n\n    constructor(bus) {\n\n        this._bus = bus;\n        this._targets = []; // frames to join or fork into\n        this._index = bus._frames.length;\n        this._wireMap = new WeakMap(); // wires as keys, handlers/pools as values\n        this._holding = false; // begins pools allowing multiple method calls -- must close with a time operation\n        this._processDef = null; // wave or poll definition\n        this._mergingWire = null;\n\n    };\n\n    define(def) {\n\n        this._processDef = def;\n        return this;\n\n    };\n\n    merge() {\n\n        this._mergingWire = new Wire();\n        return this;\n\n    };\n\n\n    handle(wire, msg, source, topic){\n\n        if(this._mergingWire){\n            this.emit(this._mergingWire, msg, source, topic);\n            return;\n        }\n\n        const hasWire = this._wireMap.has(wire);\n        if(!hasWire)\n            this._wireMap.set(wire, this._createHandler(wire));\n\n        const handler = this._wireMap.get(wire);\n        handler.handle(this, wire, msg, source || wire.name , topic);\n\n    };\n\n    emit(wire, msg, source, topic){\n\n        const len = this._targets.length;\n        for(let i = 0; i < len; i++){\n            const frame = this._targets[i];\n            frame.handle(wire, msg, source, topic);\n        }\n\n    };\n\n    _createHandler(wire){\n\n        const def = this._processDef;\n        return (def && def.name === 'pool') ? new Pool(this, wire, def) : new Wave(def);\n\n    };\n\n\n    get bus() {\n        return this._bus;\n    };\n\n    get index() {\n        return this._index;\n    };\n\n    get holding() {\n        return this._holding;\n    };\n\n    hold(){\n\n        this._holding = true;\n        this._processDef = new PoolDef();\n        return this;\n\n    };\n\n    target(frame) {\n\n        this._targets.push(frame);\n\n    };\n\n    destroy() {\n\n    };\n\n\n\n    //\n    // transform(fAny, stateful){\n    //     return this.applySyncProcess('doTransform', F.FUNCTOR(fAny), stateful);\n    // };\n    //\n\n\n    // clear(factory, ...args){\n    //     return this.buildPoolAspect('clear', factory, ...args);\n    // };\n    //\n    // // factory should define content and reset methods have signature f(msg, source) return f.content()\n    //\n\n    //\n    // until(factory, ...args){\n    //     return this.buildPoolAspect('until', factory, ...args);\n    // };\n    //\n    \n}\n\nexport default Frame;\n\n\n","\nclass WaveDef {\n\n    constructor(process, action, stateful, ...args){\n\n        this.name = 'wave';\n        this.process = process;\n        this.action = action;\n        this.stateful = stateful;\n        this.args = args;\n\n    };\n\n\n}\n\nexport default WaveDef;","\nimport Frame from './frame.js';\nimport F from './flib.js';\nimport Wire from './wire.js';\nimport WaveDef from './waveDef.js';\n\nclass Bus {\n\n    constructor(scope) {\n\n        this._frames = [];\n        this._wires = [];\n        this._dead = false;\n        this._scope = scope; // data scope\n        this._children = []; // from forks\n        this._parent = null;\n\n        if(scope)\n            scope._busList.push(this);\n\n        const f = new Frame(this);\n        this._frames.push(f);\n        this._currentFrame = f;\n\n    };\n\n    get children(){\n\n        return this._children.map((d) => d);\n\n    };\n\n    get parent() { return this._parent; };\n\n    set parent(newParent){\n\n        const oldParent = this.parent;\n\n        if(oldParent === newParent)\n            return;\n\n        if(oldParent) {\n            const i = oldParent._children.indexOf(this);\n            oldParent._children.splice(i, 1);\n        }\n\n        this._parent = newParent;\n\n        if(newParent) {\n            newParent._children.push(this);\n        }\n\n        return this;\n\n    };\n\n    get dead() {\n        return this._dead;\n    };\n\n    get holding() {\n        return this._currentFrame._holding;\n    };\n\n    get scope() {\n        return this._scope;\n    }\n\n    // NOTE: unlike most bus methods, this one returns a new current frame (not the bus!)\n\n    addFrame() {\n\n        const lastFrame = this._currentFrame;\n        const nextFrame = this._currentFrame = new Frame(this);\n        this._frames.push(nextFrame);\n        lastFrame.target(nextFrame);\n        return nextFrame;\n\n    };\n\n\n    // create stream\n    spawn(){\n\n    }\n\n    // convert each stream into a bus, wiring prior streams, dump in array\n\n    split(){\n\n        F.ASSERT_NOT_HOLDING(this);\n\n    };\n\n    fork() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        const fork = new Bus(this.scope);\n        fork.parent = this;\n        this._currentFrame.target(fork._currentFrame);\n\n        return fork;\n    };\n\n    back() {\n\n        if(!this._parent)\n            throw new Error('Cannot exit fork, parent does not exist!');\n\n        return this.parent;\n\n    };\n\n    join() {\n\n        const parent = this.back();\n        parent.add(this);\n        return parent;\n\n    }\n\n    add(bus) {\n\n        const frame = this.addFrame(); // wire from current bus\n        bus._currentFrame.target(frame); // wire from outside bus\n        return this;\n\n    };\n\n    defer() {\n        return this.timer(F.getDeferTimer);\n    };\n\n    batch() {\n        return this.timer(F.getBatchTimer);\n    };\n\n    sync() {\n        return this.timer(F.getSyncTimer);\n    };\n\n    throttle(fNum) {\n        return this.timer(F.getThrottleTimer, fNum);\n    };\n\n    hold() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().hold();\n        return this;\n\n    };\n\n    pull() {\n\n        const len = this._wires.length;\n\n        for(let i = 0; i < len; i++) {\n            const wire = this._wires[i];\n            wire.pull();\n        }\n\n        return this;\n\n    };\n\n    event(target, eventName, useCapture) {\n\n        const wire = Wire.fromEvent(target, eventName, useCapture);\n        return this.wire(wire);\n\n    };\n\n    subscribe(data, topic, name, canPull){\n\n        const wire = Wire.fromSubscribe(data, topic, name, canPull);\n        return this.wire(wire);\n\n    };\n\n    wire(wire) {\n\n        wire.target = this._frames[0];\n        this._wires.push(wire);\n        return this;\n\n    }\n\n    monitor(data, name){\n\n        const wire = Wire.fromMonitor(data, name);\n        wire.target = this._frames[0];\n        this._wires.push(wire);\n\n        return this;\n\n    };\n\n\n    scan(func, seed){\n        return this.reduce(F.getScan, func, seed);\n    };\n\n    delay(fNum) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('delay', F.FUNCTOR(fNum)));\n        return this;\n\n    };\n\n    willReset(){\n\n        F.ASSERT_IS_HOLDING(this);\n        return this.clear(F.getAlwaysTrue);\n\n    }\n\n    whenKeys(keys) {\n        return this.when(F.getWhenKeys, true, keys);\n    };\n\n    group(by) {\n\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.hold().reduce(F.getGroup, by);\n        return this;\n    };\n\n    groupByTopic() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().hold().reduce(F.getGroup, F.TO_TOPIC);\n        return this;\n    };\n\n    all() {\n        return this.reduce(F.getKeepAll);\n    };\n\n    first(n) {\n        return this.reduce(F.getKeepFirst, n);\n    };\n\n    last(n) {\n        return this.reduce(F.getKeepLast, n);\n    };\n\n    clear(factory, ...args) {\n        return this._currentFrame.clear(factory, ...args);\n    };\n\n    reduce(factory, ...args) {\n\n        const holding = this.holding;\n\n        if(!holding){\n\n            const frame = this.addFrame();\n            const def = new WaveDef('msg', factory, true, ...args);\n            frame.define(def);\n\n        } else {\n\n            const frame = this._currentFrame;\n            const def = frame._processDef;\n            def.keep = [factory, true, ...args];\n\n        }\n\n        return this;\n\n    };\n\n    timer(factory, stateful, ...args) {\n\n\n        const holding = this.holding;\n        const frame = holding ? this._currentFrame : this.addFrame().hold();\n        const def = frame._processDef;\n        def.timer = [factory, stateful, ...args];\n        this._currentFrame._holding = false; // timer ends hold\n\n        return this;\n\n    };\n\n    until(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.until(factory, ...args) :\n            this.addFrame().hold().reduce(F.getKeepLast).until(factory, ...args).timer(F.getSyncTimer);\n        return this;\n\n    };\n\n    when(factory, stateful, ...args) {\n\n        const holding = this.holding;\n\n        if(!holding){\n\n            const frame = this.addFrame();\n            const def = new WaveDef('filter', factory, stateful, ...args);\n            frame.define(def);\n\n        } else {\n\n            const frame = this._currentFrame;\n            const def = frame._processDef;\n            def.when = [factory, stateful, ...args];\n\n        }\n\n        return this;\n\n        //\n        // this.holding ?\n        //     this._currentFrame.when(factory, ...args) :\n        //     this.addFrame().hold().reduce(F.getKeepLast).when(factory, ...args).timer(F.getSyncTimer);\n        // return this;\n\n    };\n\n    run(func) {\n\n        F.ASSERT_IS_FUNCTION(func);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('run', func));\n        return this;\n\n    };\n\n    merge() {\n\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().merge();\n        return this;\n    };\n\n    msg(fAny) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('msg', F.FUNCTOR(fAny)));\n        return this;\n\n    };\n\n    transform(fAny) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().transform(fAny);\n        return this;\n\n    };\n\n    source(fStr) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('source', F.FUNCTOR(fStr)));\n        return this;\n\n    };\n\n\n    filter(func) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_IS_FUNCTION(func);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('filter', func));\n        return this;\n\n\n    };\n\n    hasKeys(keys) {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().define(new WaveDef('filter', F.getHasKeys(keys)));\n        return this;\n\n    };\n\n    skipDupes() {\n\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('filter', F.getSkipDupes, true));\n        return this;\n\n    };\n\n    toStream() {\n        // merge, fork -> immutable stream?\n    };\n\n    destroy() {\n\n        if (this.dead)\n            return this;\n\n        this._dead = true;\n\n        const wires = this._wires;\n        const len = wires.length;\n        for (let i = 0; i < len; i++) {\n            const wire = wires[i];\n            wire.destroy();\n        }\n\n        return this;\n\n    };\n\n}\n\n\n\nexport default Bus;\n","import Pool from './pool.js';\nimport F from './flib.js';\n\nclass Stream {\n\n    constructor(){\n\n        this.dead = false;\n        this.children = [];\n        this.name = null;\n        this.pool = null;\n        this.cleanupMethod = F.NOOP; // to cleanup subscriptions\n        this.pull = F.NOOP; // to retrieve and emit stored values from a source\n        this.processMethod = this.emit;\n        this.actionMethod = null; // for run, transform, filter, name, delay\n\n    };\n\n    handle(msg, source) {\n\n        if(this.dead) // true if canceled or disposed midstream\n            return this;\n\n        this.processMethod(msg, this.name || source); // handle method = doDelay, doGroup, doHold, , doFilter\n\n        return this;\n\n    };\n\n    drop(stream){\n\n        const children = this.children;\n        const i = children.indexOf(stream);\n\n        if(i !== -1)\n            children.splice(i, 1);\n\n    };\n\n    addTarget(stream){\n        this.children.push(stream);\n    };\n\n    emit(msg, source, topic, thisStream){\n\n        thisStream = thisStream || this; // allow callbacks with context instead of bind (massively faster)\n        source = thisStream.name || source;\n\n        const children = thisStream.children;\n        const len = children.length;\n\n        for(let i = 0; i < len; i++){\n            const c = children[i];\n            c.handle(msg, source, topic);\n        }\n\n    };\n\n    doFilter(msg, source, topic) {\n\n        if(!this.actionMethod(msg, source, topic))\n            return;\n        this.emit(msg, source, topic);\n\n    };\n\n\n    doMsg(msg, source, topic) {\n\n        msg = this.actionMethod(msg, source, topic);\n        this.emit(msg, source, topic);\n\n    };\n\n    doTransform(msg, source, topic) {\n\n\n        msg = this.actionMethod.msg ? this.actionMethod.msg(msg, source, topic) : msg;\n        source = this.actionMethod.source ? this.actionMethod.source(msg, source, topic) : source;\n        topic = this.actionMethod.topic ? this.actionMethod.topic(msg, source, topic) : topic;\n        this.emit(msg, source, topic);\n\n    };\n\n    doDelay(msg, source, topic) {\n\n        // todo add destroy -> kills timeout\n        // passes 'this' to avoid bind slowdown\n        setTimeout(this.emit, this.actionMethod(msg, source, topic) || 0, msg, source, topic, this);\n\n    };\n\n    doSource(msg, source, topic) {\n\n        this.name = this.actionMethod(); // todo shoehorned -- this needs it's own setup\n        //source = this.actionMethod(msg, source, topic);\n        // this.name = function(){ return }\n        this.emit(msg, this.name || source, topic);\n\n    };\n\n\n    doRun(msg, source, topic) {\n\n        this.actionMethod(msg, source, topic);\n        this.emit(msg, source, topic);\n\n    };\n\n    createPool(){\n\n        this.pool = new Pool(this);\n    };\n\n    doPool(msg, source, topic) {\n\n        this.pool.handle(msg, this.name || source, topic);\n\n    };\n\n    destroy(){\n\n        if(this.dead)\n            return;\n\n        this.cleanupMethod(); // should remove an eventListener if present\n\n    };\n\n}\n\n\nStream.fromMonitor = function(data, name, canPull){\n\n    const stream = new Stream();\n    const streamName = name || data.name;\n\n    stream.name = streamName;\n\n    const toStream = function(msg, source, topic){\n        stream.emit(msg, streamName, topic);\n    };\n\n    stream.cleanupMethod = function(){\n        data.unsubscribe(toStream);\n    };\n\n    if(canPull){\n        stream.pull = function(){\n            const packet = data.survey();\n            if(packet) {\n                const msg = packet._msg;\n                const source = streamName || packet._source;\n                const topic = packet._topic;\n                stream.emit(msg, source, topic, stream);\n            }\n        }\n    }\n\n    data.monitor(toStream);\n\n    return stream;\n\n};\n\n\n\nStream.fromSubscribe = function(data, topic, name, canPull){\n\n    const stream = new Stream();\n    const streamName = name || topic || data.name;\n    stream.name = streamName;\n\n    const toStream = function(msg, source, topic){\n        stream.emit(msg, streamName, topic);\n    };\n\n    stream.cleanupMethod = function(){\n        data.unsubscribe(toStream, topic);\n    };\n\n    if(canPull){\n        stream.pull = function(){\n            const packet = data.peek();\n            if(packet) {\n                const msg = packet._msg;\n                const source = streamName || packet._source;\n                const topic = packet._topic;\n                stream.emit(msg, source, topic, stream);\n            }\n        }\n    }\n\n    data.subscribe(toStream, topic);\n\n    return stream;\n\n};\n\n\n\nStream.fromEvent = function(target, eventName, useCapture){\n\n    useCapture = !!useCapture;\n\n    const stream = new Stream();\n    stream.name = eventName;\n\n    const on = target.addEventListener || target.addListener || target.on;\n    const off = target.removeEventListener || target.removeListener || target.off;\n\n    const toStream = function(msg){\n        stream.handle(msg, eventName);\n    };\n\n    stream.cleanupMethod = function(){\n        off.call(target, eventName, toStream, useCapture);\n    };\n\n    on.call(target, eventName, toStream, useCapture);\n\n    return stream;\n\n};\n\n\nexport default Stream;","\nimport Scope from './scope.js';\nimport Wire from './wire.js';\nimport Bus from './bus.js';\n\n\nconst Catbus = {};\n\nlet _batchQueue = [];\nlet _primed = false;\n\n\n\nCatbus.fromEvent = function(target, eventName, useCapture){\n\n    const bus = new Bus();\n    bus.event(target, eventName, useCapture);\n    return bus;\n\n};\n\n// todo stable output queue -- output pools go in a queue that runs after the batch q is cleared, thus run once only\n\nCatbus.enqueue = function(pool){\n\n    _batchQueue.push(pool);\n\n    if(!_primed) { // register to flush the queue\n        _primed = true;\n        if (typeof window !== 'undefined' && window.requestAnimationFrame) requestAnimationFrame(Catbus.flush);\n        else process.nextTick(Catbus.flush);\n    }\n\n};\n\n\nCatbus.createChild = Catbus.scope = function(name){\n\n    return new Scope(name);\n\n};\n\n\nCatbus.flush = function(){\n\n    _primed = false;\n\n    let cycles = 0;\n    let q = _batchQueue;\n    _batchQueue = [];\n\n    while(q.length) {\n\n        while (q.length) {\n            const pool = q.shift();\n            pool.release();\n        }\n\n        q = _batchQueue;\n        _batchQueue = [];\n\n        cycles++;\n        if(cycles > 10)\n            throw new Error('Flush batch cycling loop > 10.', q);\n\n    }\n\n};\n\n\n\nexport default Catbus;\n"],"names":["ALWAYS_TRUE","ALWAYS_FALSE","TO_SOURCE","msg","source","TO_TOPIC","topic","TO_MSG","NOOP","FUNCTOR","val","isValid","type","reverseLookup","hasOwnProperty","pass","frame","wire","emit","toTickStackString","str","chunks","split","strStack","ticking","length","c","shift","push","join","parse","isProcess","sentences","map","d","trim","filter","i","chunk","sentence","parseSentence","validate","cmdList","firstPhrase","s","j","phrase","name","validateReactPhrase","hasReaction","nw","operation","reactionsByName","withReactionsByName","Error","validateProcessPhrase","firstOperation","thenByName","result","parsePhrase","words","rawWords","len","rawWord","rawChunks","inMethod","next","trimmed","nameAndOperation","firstChar","namesBySymbol","start","slice","extracts","maybe","monitor","alias","need","tickStack","indexOf","prop","silentFail","NyanWord","getPacketFromDataWord","scope","word","data","find","peek","getSurveyFromDataWord","survey","throwError","log","e","this","getDoSkipNamedDupes","names","lastMsg","diff","getDoWrite","write","getDoSpray","wordByAlias","dataByAlias","msgPart","silentWrite","refresh","getDoRead","firstWord","getDoReadMultiple","getDoReadSingle","getDoAnd","packet","isAndOperation","p","key","value","getDataWire","canPull","Wire","fromMonitor","fromSubscribe","isObject","v","getEventWire","target","fromEvent","useCapture","doExtracts","extract","getNeedsArray","getDoMsgHashExtract","extractsByAlias","getDoMsgExtract","applyReaction","bus","skipDupes","_wires","merge","group","batch","hasKeys","isTruthy","isFalsey","applyMethod","undefined","applyProcess","context","node","needs","whenKeys","run","applyMsgProcess","method","f","call","applySourceProcess","applyFilterProcess","nyanToBus","nyan","Nyan","cmd","sync","fork","back","_destroyEach","arr","destroy","Func","args","func","pool","enqueue","release","fNum","timedRelease","fromTimeout","stream","dead","nowEmpty","keep","isEmpty","timeoutId","setTimeout","wasEmpty","msgDuringTimer","auto","n","Infinity","buffer","isBuffer","content","seed","hasSeed","arguments","acc","initMsg","reset","groupBy","hash","g","k","last","firstMsg","latched","messages","keys","keyHash","messagesByKey","noLatch","hadMsg","holding","To_MSG","Packet","_msg","_topic","_source","_timestamp","Date","now","DATA_TYPES","SubscriberList","_subscribers","_lastPacket","_data","_name","_dead","silently","currentPacket","ACTION","subscribers","concat","handle","watcher","splice","Data","NONE","_scope","_type","_wildcardSubscriberList","_subscriberListsByTopic","Map","_throwDead","values","list","get","set","expectedType","subscribe","_demandSubscriberList","add","remove","entries","m","lastPacket","subscriberList","MIRROR","read","Wave","def","process","action","stateful","callback","Pool","fromDef","factory","F","getKeepLast","when","until","timer","clear","isPrimed","hasContent","PoolDef","cleanupMethod","pull","wireName","toWire","unsubscribe","eventName","on","addEventListener","addListener","off","removeEventListener","removeListener","Frame","_bus","_targets","_index","_frames","_wireMap","WeakMap","_holding","_processDef","_mergingWire","has","_createHandler","WaveDef","Bus","_children","_parent","_busList","_currentFrame","lastFrame","nextFrame","ASSERT_NOT_HOLDING","parent","addFrame","getDeferTimer","getBatchTimer","getSyncTimer","getThrottleTimer","hold","reduce","getScan","ASSERT_NEED_ONE_ARGUMENT","define","ASSERT_IS_HOLDING","getAlwaysTrue","getWhenKeys","by","getGroup","getKeepAll","getKeepFirst","ASSERT_IS_FUNCTION","fAny","transform","fStr","getHasKeys","getSkipDupes","wires","newParent","oldParent","operationDefs","sym","react","solo","follow","event","then","output","operationsBySymbol","operationsByName","symbolsByName","op","Stream","children","processMethod","actionMethod","thisStream","streamName","toStream","idCounter","Scope","_id","_dataList","_valves","_mirrors","child","mirror","Object","create","grab","_createData","verify","STATE","state","_createMirror","required","dataSet","findDataSet","appliedValves","dataList","valves","mirrors","size","delete","possibles","localData","foundInner","writes","Array","isArray","_multiWriteArray","_multiWriteHash","writeArray","w","writeHash","from","Catbus","_batchQueue","_primed","window","requestAnimationFrame","flush","nextTick","createChild","cycles","q"],"mappings":"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"}