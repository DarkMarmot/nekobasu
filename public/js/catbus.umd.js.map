{"version":3,"file":"catbus.umd.js","sources":["../src/packet.js","../src/dataTypes.js","../src/subscriberList.js","../src/data.js","../src/wave.js","../src/flib.js","../src/pool.js","../src/poolDef.js","../src/wire.js","../src/frame.js","../src/waveDef.js","../src/bus.js","../src/nyan.js","../src/nyanBus.js","../src/scope.js","../src/catbus.js","../src/main.js"],"sourcesContent":["\nclass Packet {\n\n    constructor(msg, topic, source) {\n        this._msg       = msg;\n        this._topic     = topic;\n        this._source    = source;\n        this._timestamp = Date.now();\n    };\n\n    get msg() { return this._msg; };\n    get topic() { return this._topic; };\n    get source() { return this._source; };\n    get timestamp() { return this._timestamp; };\n\n}\n\nexport default Packet;","\n\nconst DATA_TYPES = {\n\n    ACTION:   'action',\n    MIRROR:   'mirror',\n    STATE:    'state',\n    COMPUTED: 'computed',\n    NONE:     'none',\n    ANY:      'any'\n\n};\n\nconst reverseLookup = {};\n\nfor(const p in DATA_TYPES){\n    const v = DATA_TYPES[p];\n    reverseLookup[v] = p;\n}\n\nfunction isValid(type){\n    return reverseLookup.hasOwnProperty(type);\n}\n\n\nexport { DATA_TYPES, isValid};\n\n","\nimport Packet from './packet.js';\nimport { DATA_TYPES } from './dataTypes';\n\nclass SubscriberList {\n\n    constructor(topic, data) {\n\n        this._topic = topic;\n        this._subscribers = [];\n        this._lastPacket = null;\n        this._data = data;\n        this._name = data._name;\n        this._dead = false;\n\n    };\n\n    get lastPacket() { return this._lastPacket; };\n    get data() { return this._data; };\n    get name() { return this._name; };\n    get dead() { return this._dead; };\n    get topic() { return this._topic; };\n\n    handle(msg, topic, silently){\n\n        if(this.dead)\n            return;\n\n        topic = topic || this.topic;\n        let source = this.name;\n        let currentPacket = new Packet(msg, topic, source);\n\n        if(this.data.type !== DATA_TYPES.ACTION) // actions do not store data (ephemeral and immediate)\n            this._lastPacket = currentPacket;\n\n        let subscribers = [].concat(this._subscribers); // call original sensors in case subscriptions change mid loop\n        let len = subscribers.length;\n\n        if(!silently) {\n            for (let i = 0; i < len; i++) {\n                let s = subscribers[i];\n                typeof s === 'function' ? s.call(s, msg, currentPacket) : s.handle(msg, currentPacket);\n            }\n        }\n\n    };\n\n    destroy(){\n\n        if(this.dead)\n            return;\n\n        this._subscribers = null;\n        this._lastPacket = null;\n        this._dead = true;\n\n    };\n\n    add(watcher){\n\n        this._subscribers.push(watcher);\n\n    };\n\n    remove(watcher){\n\n        let i = this._subscribers.indexOf(watcher);\n\n        if(i !== -1)\n            this._subscribers.splice(i, 1);\n\n    };\n\n}\n\n\nexport default SubscriberList;\n\n","\nimport SubscriberList from './subscriberList.js';\nimport {isValid, DATA_TYPES} from './dataTypes.js';\n\nconst NO_TOPIC = '___NO_TOPIC___';\n\nclass Data {\n\n    constructor(scope, name, type) {\n\n        type = type || DATA_TYPES.NONE;\n\n        if(!isValid(type))\n            throw new Error('Invalid Data of type: ' + type);\n\n        this._scope      = scope;\n        this._name       = name;\n        this._type       = type;\n        this._dead       = false;\n\n        this._wildcardSubscriberList = new SubscriberList(null, this);\n        this._subscriberListsByTopic = new Map();\n\n    };\n\n    get scope() { return this._scope; };\n    get name() { return this._name; };\n    get type() { return this._type; };\n    get dead() { return this._dead; };\n\n    destroy(){\n\n        if(this.dead)\n            this._throwDead();\n        \n        for(const list of this._subscriberListsByTopic.values()){\n            list.destroy();\n        }\n\n        this._dead = true;\n\n    };\n    \n    _demandSubscriberList(topic){\n\n        topic = topic || undefined;\n        let list = this._subscriberListsByTopic.get(topic);\n\n        if(list)\n            return list;\n\n        list = new SubscriberList(topic, this);\n        this._subscriberListsByTopic.set(topic, list);\n\n        return list;\n        \n    };\n\n    verify(expectedType){\n\n        if(this.type === expectedType)\n            return this;\n\n        throw new Error('Data ' + this.name + ' requested as type ' + expectedType + ' exists as ' + this.type);\n\n    };\n\n    follow(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.subscribe(watcher, topic);\n        let packet = this.peek();\n\n        if(packet)\n            typeof watcher === 'function' ? watcher.call(watcher, packet.msg, packet) : watcher.handle(packet.msg, packet);\n\n        return this;\n\n    };\n\n    subscribe(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this._demandSubscriberList(topic).add(watcher);\n\n        return this;\n\n    };\n\n    monitor(watcher){\n\n        if(this.dead)\n            this._throwDead();\n\n        this._wildcardSubscriberList.add(watcher);\n\n        return this;\n\n    };\n\n    unsubscribe(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this._demandSubscriberList(topic).remove(watcher);\n        this._wildcardSubscriberList.remove(watcher);\n\n        return this;\n\n    };\n\n    topics(){\n\n        return this._subscriberListsByTopic.keys();\n\n    };\n\n    survey(){ // get entire key/value store by topic:lastPacket\n\n        const entries = this._subscriberListsByTopic.entries();\n        const m = new Map();\n        for (const [key, value] of entries) {\n            m.set(key, value.lastPacket);\n        }\n\n        return m;\n    };\n\n\n    peek(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        const subscriberList = this._subscriberListsByTopic.get(topic);\n        return subscriberList ? subscriberList.lastPacket : null;\n\n    };\n\n\n    read(topic) {\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        let packet = this.peek(topic);\n        return (packet) ? packet.msg : undefined;\n\n    };\n\n\n    silentWrite(msg, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.write(msg, topic, true);\n\n    };\n\n\n    write(msg, topic, silently){\n\n        if(this.dead)\n            this._throwDead();\n\n        if(this.type === DATA_TYPES.MIRROR)\n            throw new Error('Mirror Data: ' + this.name + ' is read-only');\n\n        topic = topic || undefined;\n        const list = this._demandSubscriberList(topic);\n        list.handle(msg, topic, silently);\n        this._wildcardSubscriberList.handle(msg, topic, silently);\n\n    };\n\n\n    refresh(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        const lastPacket = this.peek(topic);\n\n        if(lastPacket)\n            this.write(lastPacket._msg, topic);\n\n        return this;\n\n    };\n\n\n    toggle(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.write(!this.read(topic), topic);\n\n        return this;\n\n    };\n\n    _throwDead(){\n\n        throw new Error('Data: ' + this.name + ' is already dead.');\n\n    };\n\n}\n\nexport default Data;\n\n\n\n\n\n\n\n\n\n\n\n\n","\nfunction pass(frame, wire, msg, source, topic) {\n\n    frame.emit(wire, msg, source, topic);\n\n}\n\n\nclass Wave {\n\n    constructor(def){\n\n        this.process = (def && def.process) ? this[def.process] : pass;\n        this.action = def ? (def.stateful ? def.action(...def.args) : def.action) : null;\n\n    };\n\n    handle(frame, wire, msg, source, topic) {\n        this.process(frame, wire, msg, source, topic)\n    };\n\n    run(frame, wire, msg, source, topic) {\n\n        this.action(msg, source, topic);\n        frame.emit(wire, msg, source, topic);\n\n    };\n\n    msg(frame, wire, msg, source, topic) {\n\n        msg = this.action(msg, source, topic);\n        frame.emit(wire, msg, source, topic);\n\n    }\n\n    source(frame, wire, msg, source, topic) {\n\n        source = this.action(msg, source, topic);\n        frame.emit(wire, msg, source, topic);\n\n    }\n\n    filter(frame, wire, msg, source, topic) {\n\n        if(!this.action(msg, source, topic))\n            return;\n        frame.emit(wire, msg, source, topic);\n\n    };\n\n    delay(frame, wire, msg, source, topic) {\n\n        function callback(){\n            frame.emit(wire, msg, source, topic);\n        }\n\n        setTimeout(callback, this.action(msg, source, topic) || 0, msg, source, topic);\n\n    };\n\n}\n\n\nexport default Wave;","\nimport Catbus from './catbus.js';\n\nfunction ALWAYS_TRUE(){\n    return true;\n}\n\nfunction ALWAYS_FALSE(){\n    return false;\n}\n\n\nfunction TO_SOURCE(msg, source) {\n    return source;\n}\n\nfunction TO_TOPIC(msg, source, topic) {\n    return topic;\n}\n\nfunction TO_MSG(msg) {\n    return msg;\n}\n\nfunction NOOP(){\n\n}\n\n\nfunction FUNCTOR(val) {\n    return (typeof val === 'function') ? val : function() { return val; };\n}\n\nconst Func = {\n\n\n    ASSERT_NEED_ONE_ARGUMENT: function(args){\n        if(args.length < 1)\n            throw new Error('Method requires at least one argument.');\n    },\n\n    ASSERT_IS_FUNCTION: function(func){\n        if(typeof func !== 'function')\n            throw new Error('Argument [func] is not of type function.');\n    },\n\n    getAlwaysTrue: function(){\n       return function(){ return true;}\n    },\n\n    getBatchTimer: function(pool){\n\n            Catbus.enqueue(pool);\n\n    },\n\n    getSyncTimer: function(){\n        return function(pool) {\n            pool.release(pool);\n        }\n    },\n\n    getDeferTimer: function(){\n        return function(pool) {\n            setTimeout(pool.release, 0, pool);\n        }\n    },\n\n    getThrottleTimer: function(fNum){\n\n        const pool = this;\n        fNum = FUNCTOR(fNum);\n        let wasEmpty = false;\n        let timeoutId = null;\n        let msgDuringTimer = false;\n        const auto = pool.keep.auto;\n\n        function timedRelease(fromTimeout){\n\n            if(pool.stream.dead)\n                return;\n\n            const nowEmpty = pool.keep.isEmpty;\n\n            if(!fromTimeout){\n                if(!timeoutId) {\n                    pool.release(pool);\n                    wasEmpty = false;\n                    timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n                } else {\n                    msgDuringTimer = true;\n                }\n                return;\n            }\n\n            if(nowEmpty){\n                if(wasEmpty){\n                    // throttle becomes inactive\n                } else {\n                    // try one more time period to maintain throttle\n                    wasEmpty = true;\n                    msgDuringTimer = false;\n                    timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n                }\n            } else {\n                pool.release(pool);\n                wasEmpty = false;\n                timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n            }\n\n        }\n\n        return timedRelease;\n\n    },\n\n    getQueue: function(n){\n\n        n = n || Infinity;\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            if(buffer.length < n)\n                buffer.push(msg);\n            return buffer;\n        };\n\n        f.isBuffer = ALWAYS_TRUE;\n\n        f.next = function(){\n            return buffer.shift();\n        };\n\n        f.isEmpty = function(){\n            return buffer.length === 0;\n        };\n\n        f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getScan: function(func, seed){\n\n        const hasSeed = arguments.length === 2;\n        let acc;\n        let initMsg = true;\n\n        const f = function(msg, source){\n\n            if(initMsg){\n                initMsg = false;\n                if(hasSeed){\n                    acc = func(seed, msg, source);\n                } else {\n                    acc = msg;\n                }\n            } else {\n                acc = func(acc, msg, source);\n            }\n\n            return acc;\n\n        };\n\n        f.reset = NOOP;\n\n        f.next = f.content = function(){\n            return acc;\n        };\n\n\n        return f;\n    },\n\n    getGroup: function(groupBy){\n\n        groupBy = groupBy || TO_SOURCE;\n        const hash = {};\n\n        const f = function(msg, source){\n\n            const g = groupBy(msg, source);\n            if(g) {\n                hash[g] = msg;\n            } else { // no source, copy message props into hash to merge nameless streams of key data\n                for(const k in msg){\n                    hash[k] = msg[k];\n                }\n            }\n\n            return hash;\n\n        };\n\n        f.reset = function(){\n            for(const k in hash){\n                delete hash[k];\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return hash;\n        };\n\n        return f;\n\n    },\n\n    getHash: function(groupBy){\n\n        groupBy = groupBy || TO_SOURCE;\n        const hash = {};\n\n        const f = function(msg, source){\n\n            const g = groupBy(msg, source);\n            hash[g] = msg;\n            return hash;\n\n        };\n\n        f.reset = function(){\n            for(const k in hash){\n                delete hash[k];\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return hash;\n        };\n\n        return f;\n\n    },\n\n\n    getKeepLast: function(n){\n\n        if(!n || n < 0) {\n\n            let last;\n\n            const f = function(msg, source){\n                return last = msg;\n            };\n\n            f.reset = function(){\n                f.isEmpty = true;\n            };\n\n            f.next = f.content = function(){\n                return last;\n            };\n\n            return f;\n\n        }\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            buffer.push(msg);\n            if(buffer.length > n)\n                buffer.shift();\n            return buffer;\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n\n\n    getKeepFirst: function(n){\n\n        if(!n || n < 0) {\n\n            let firstMsg;\n            let hasFirst = false;\n            const f = function (msg, source) {\n                return hasFirst ? firstMsg : firstMsg = msg;\n            };\n\n            f.reset = function(){\n                firstMsg = false;\n                f.isEmpty = true;\n            };\n\n            f.next = f.content = function(){\n                return firstMsg;\n            };\n\n            return f;\n        }\n\n        const buffer = [];\n\n        const f = function(msg, source){\n\n            if(buffer.length < n)\n                buffer.push(msg);\n            return buffer;\n\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getKeepAll: function(){\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            buffer.push(msg);\n            return buffer;\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getWhenCount: function(n) {\n\n        let latched = false;\n\n        const f = function(messages){\n            latched = latched || messages.length >= n;\n            return latched;\n        };\n\n        f.reset = function(){\n            latched = false;\n        };\n\n        return f;\n\n    },\n\n    getWhenKeys: function(keys) {\n\n        const keyHash = {};\n        const len = keys.length;\n\n        for(let i = 0; i < len; i++){\n            const k = keys[i];\n            keyHash[k] = true;\n        }\n\n        let latched = false;\n\n        const f = function (messagesByKey) {\n\n            if(latched)\n                return true;\n\n            for (let i = 0; i < len; i++) {\n                const k = keys[i];\n                if (!messagesByKey.hasOwnProperty(k))\n                    return false;\n            }\n\n            return latched = true;\n\n        };\n\n        f.reset = function(){\n            latched = false;\n            for(const k in keyHash){\n                delete keyHash[k];\n            }\n        };\n\n        return f;\n\n    },\n\n    getHasKeys: function(keys, noLatch) {\n\n        let latched = false;\n        const len = keys.length;\n\n        return function (msg) {\n\n            if(latched || !len)\n                return true;\n\n            for(let i = 0; i < len; i++) {\n\n                const k = keys[i];\n                if(!msg.hasOwnProperty(k))\n                    return false;\n            }\n\n            if(!noLatch)\n                latched = true;\n\n            return true;\n\n        }\n\n    },\n\n\n    getSkipDupes: function() {\n\n        let hadMsg = false;\n        let lastMsg;\n\n        return function (msg) {\n\n            const diff = !hadMsg || msg !== lastMsg;\n            lastMsg = msg;\n            hadMsg = true;\n            return diff;\n\n        }\n\n    },\n\n\n    ASSERT_NOT_HOLDING: function(bus){\n        if(bus.holding)\n            throw new Error('Method cannot be invoked while holding messages in the frame.');\n    },\n\n    ASSERT_IS_HOLDING: function(bus){\n        if(!bus.holding)\n            throw new Error('Method cannot be invoked unless holding messages in the frame.');\n    }\n\n};\n\nFunc.TO_SOURCE = TO_SOURCE;\nFunc.TO_TOPIC = TO_TOPIC;\nFunc.To_MSG = TO_MSG;\nFunc.FUNCTOR = FUNCTOR;\nFunc.ALWAYS_TRUE = ALWAYS_TRUE;\nFunc.ALWAYS_FALSE = ALWAYS_FALSE;\nFunc.NOOP = NOOP;\n\nexport default Func;","\nimport F from './flib.js';\n\nclass Pool {\n\n    constructor(frame, wire, def){\n\n        this.frame = frame;\n        this.wire = wire;\n\n        function fromDef(name){\n\n            if(!def[name])\n                return null;\n\n            const [factory, stateful, ...args] = def[name];\n\n            return stateful ? factory.call(this, ...args) : factory;\n\n        }\n\n        this.keep = fromDef('keep') || F.getKeepLast();\n        this.when = fromDef('when') || F.ALWAYS_TRUE;\n        this.until = fromDef('until') || F.ALWAYS_TRUE;\n        this.timer = fromDef('timer');  // throttle, debounce, defer, batch, sync\n        this.clear = fromDef('clear') || F.ALWAYS_FALSE;\n\n        this.isPrimed = false;\n\n\n    };\n\n    handle(frame, wire, msg, source, topic) {\n\n        this.keep(msg, source, topic);\n        if(!this.isPrimed){\n            const content = this.keep.content();\n            if(this.when(content)){\n                this.isPrimed = true;\n                this.timer(this);\n            }\n        }\n\n    };\n\n    build(prop, factory, ...args){\n        this[prop] = factory.call(this, ...args);\n    };\n\n    release(pool) {\n\n        pool = pool || this;\n        const hasContent = !pool.keep.isEmpty;\n        const msg = hasContent && pool.keep.next();\n\n        if(pool.clear()){\n            pool.keep.reset();\n            pool.when.reset();\n        }\n\n        pool.isPrimed = false;\n\n        if(hasContent)\n            pool.frame.emit(pool.wire, msg);\n\n    };\n\n}\n\n\nexport default Pool;","\nclass PoolDef {\n\n    constructor(){\n\n        this.name = 'pool';\n        this.keep  = null;\n        this.when  = null;\n        this.until = null;\n        this.timer = null;\n        this.clear = null;\n\n    };\n\n}\n\n\nexport default PoolDef;","import F from './flib.js';\n\nclass Wire {\n\n    constructor(name){\n\n        this.target = null; // a frame in a bus\n        this.dead = false;\n        this.name = name;\n        this.cleanupMethod = F.NOOP; // to cleanup subscriptions\n        this.pull = F.NOOP; // to retrieve and emit stored values from a source\n\n    };\n\n    handle(msg, source, topic) {\n\n        if(!this.dead && this.target)\n            this.target.handle(this, msg, this.name || source, topic);\n\n        return this;\n\n    };\n\n    destroy(){\n\n        if(!this.dead && this.target){\n            this.dead = true;\n            this.cleanupMethod();\n        }\n\n    };\n\n}\n\n\nWire.fromInterval = function(delay, name){\n\n    const wire = new Wire(name);\n\n    const toWire = function(msg){\n        wire.handle(msg);\n    };\n\n    const id = setInterval(toWire, delay);\n\n    wire.cleanupMethod = function(){\n        clearInterval(id);\n    };\n\n    return wire;\n\n};\n\n\nWire.fromMonitor = function(data, name){\n\n    const wire = new Wire(name);\n\n    const toWire = function(msg, source, topic){\n        wire.handle(msg, source, topic);\n    };\n\n    wire.cleanupMethod = function(){\n        data.unsubscribe(toWire);\n    };\n\n    data.monitor(toWire);\n\n    return wire;\n\n};\n\n\n\nWire.fromSubscribe = function(data, topic, name, canPull){\n\n    const wire = new Wire(name || topic || data.name);\n\n    const toWire = function(msg, source, topic){\n        wire.handle(msg, source, topic);\n    };\n\n    wire.cleanupMethod = function(){\n        data.unsubscribe(toWire, topic);\n    };\n\n    if(canPull){\n        wire.pull = function(){\n            const packet = data.peek();\n            if(packet) {\n                const msg = packet._msg;\n                const source = packet._source;\n                const topic = packet._topic;\n                wire.handle(msg, source, topic);\n            }\n        }\n    }\n\n    data.subscribe(toWire, topic);\n\n    return wire;\n\n};\n\n\n\nWire.fromEvent = function(target, eventName, useCapture){\n\n    useCapture = !!useCapture;\n\n    const wire = new Wire(eventName);\n\n    const on = target.addEventListener || target.addListener || target.on;\n    const off = target.removeEventListener || target.removeListener || target.off;\n\n    const toWire = function(msg){\n        wire.handle(msg, eventName);\n    };\n\n    wire.cleanupMethod = function(){\n        off.call(target, eventName, toWire, useCapture);\n    };\n\n    on.call(target, eventName, toWire, useCapture);\n\n    return wire;\n\n};\n\n\nexport default Wire;","\nimport Wave from './wave.js';\nimport Pool from './pool.js';\nimport PoolDef from './poolDef.js';\nimport Wire from './wire.js';\n\nclass Frame {\n\n    constructor(bus) {\n\n        this._bus = bus;\n        this._targets = []; // frames to join or fork into\n        this._index = bus._frames.length;\n        this._wireMap = new WeakMap(); // wires as keys, handlers/pools as values\n        this._holding = false; // begins pools allowing multiple method calls -- must close with a time operation\n        this._processDef = null; // wave or poll definition\n        this._mergingWire = null;\n\n    };\n\n    define(def) {\n\n        this._processDef = def;\n        return this;\n\n    };\n\n    merge() {\n\n        this._mergingWire = new Wire();\n        return this;\n\n    };\n\n\n    handle(wire, msg, source, topic){\n\n        if(this._mergingWire){\n            this.emit(this._mergingWire, msg, source, topic);\n            return;\n        }\n\n        const hasWire = this._wireMap.has(wire);\n        if(!hasWire)\n            this._wireMap.set(wire, this._createHandler(wire));\n\n        const handler = this._wireMap.get(wire);\n        handler.handle(this, wire, msg, source || wire.name , topic);\n\n    };\n\n    emit(wire, msg, source, topic){\n\n        const len = this._targets.length;\n        for(let i = 0; i < len; i++){\n            const frame = this._targets[i];\n            frame.handle(wire, msg, source, topic);\n        }\n\n    };\n\n    _createHandler(wire){\n\n        const def = this._processDef;\n        return (def && def.name === 'pool') ? new Pool(this, wire, def) : new Wave(def);\n\n    };\n\n\n    get bus() {\n        return this._bus;\n    };\n\n    get index() {\n        return this._index;\n    };\n\n    get holding() {\n        return this._holding;\n    };\n\n    hold(){\n\n        this._holding = true;\n        this._processDef = new PoolDef();\n        return this;\n\n    };\n\n    target(frame) {\n\n        this._targets.push(frame);\n\n    };\n\n    destroy() {\n\n    };\n\n\n\n    //\n    // transform(fAny, stateful){\n    //     return this.applySyncProcess('doTransform', F.FUNCTOR(fAny), stateful);\n    // };\n    //\n\n\n    // clear(factory, ...args){\n    //     return this.buildPoolAspect('clear', factory, ...args);\n    // };\n    //\n    // // factory should define content and reset methods have signature f(msg, source) return f.content()\n    //\n\n    //\n    // until(factory, ...args){\n    //     return this.buildPoolAspect('until', factory, ...args);\n    // };\n    //\n    \n}\n\nexport default Frame;\n\n\n","\nclass WaveDef {\n\n    constructor(process, action, stateful, ...args){\n\n        this.name = 'wave';\n        this.process = process;\n        this.action = action;\n        this.stateful = stateful;\n        this.args = args;\n\n    };\n\n\n}\n\nexport default WaveDef;","\nimport Frame from './frame.js';\nimport F from './flib.js';\nimport Wire from './wire.js';\nimport WaveDef from './waveDef.js';\n\nclass Bus {\n\n    constructor(scope) {\n\n        this._frames = [];\n        this._wires = [];\n        this._dead = false;\n        this._scope = scope; // data scope\n        this._children = []; // from forks\n        this._parent = null;\n\n        if(scope)\n            scope._busList.push(this);\n\n        const f = new Frame(this);\n        this._frames.push(f);\n        this._currentFrame = f;\n\n    };\n\n    get children(){\n\n        return this._children.map((d) => d);\n\n    };\n\n    get parent() { return this._parent; };\n\n    set parent(newParent){\n\n        const oldParent = this.parent;\n\n        if(oldParent === newParent)\n            return;\n\n        if(oldParent) {\n            const i = oldParent._children.indexOf(this);\n            oldParent._children.splice(i, 1);\n        }\n\n        this._parent = newParent;\n\n        if(newParent) {\n            newParent._children.push(this);\n        }\n\n        return this;\n\n    };\n\n    get dead() {\n        return this._dead;\n    };\n\n    get holding() {\n        return this._currentFrame._holding;\n    };\n\n    get scope() {\n        return this._scope;\n    }\n\n    // NOTE: unlike most bus methods, this one returns a new current frame (not the bus!)\n\n    addFrame() {\n\n        const lastFrame = this._currentFrame;\n        const nextFrame = this._currentFrame = new Frame(this);\n        this._frames.push(nextFrame);\n        lastFrame.target(nextFrame);\n        return nextFrame;\n\n    };\n\n\n    // create stream\n    spawn(){\n\n    }\n\n    // convert each stream into a bus, wiring prior streams, dump in array\n\n    split(){\n\n        F.ASSERT_NOT_HOLDING(this);\n\n    };\n\n    fork() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        const fork = new Bus(this.scope);\n        fork.parent = this;\n        this._currentFrame.target(fork._currentFrame);\n\n        return fork;\n    };\n\n    back() {\n\n        if(!this._parent)\n            throw new Error('Cannot exit fork, parent does not exist!');\n\n        return this.parent;\n\n    };\n\n    join() {\n\n        const parent = this.back();\n        parent.add(this);\n        return parent;\n\n    }\n\n    add(bus) {\n\n        const frame = this.addFrame(); // wire from current bus\n        bus._currentFrame.target(frame); // wire from outside bus\n        return this;\n\n    };\n\n    defer() {\n        return this.timer(F.getDeferTimer);\n    };\n\n    batch() {\n        return this.timer(F.getBatchTimer);\n    };\n\n    sync() {\n        return this.timer(F.getSyncTimer);\n    };\n\n    throttle(fNum) {\n        return this.timer(F.getThrottleTimer, fNum);\n    };\n\n    hold() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().hold();\n        return this;\n\n    };\n\n    pull() {\n\n        const len = this._wires.length;\n\n        for(let i = 0; i < len; i++) {\n            const wire = this._wires[i];\n            wire.pull();\n        }\n\n        return this;\n\n    };\n\n    event(target, eventName, useCapture) {\n\n        const wire = Wire.fromEvent(target, eventName, useCapture);\n        return this.wire(wire);\n\n    };\n\n    subscribe(data, topic, name, canPull){\n\n        const wire = Wire.fromSubscribe(data, topic, name, canPull);\n        return this.wire(wire);\n\n    };\n\n    interval(delay, name){\n\n        const wire = Wire.fromInterval(delay, name);\n        return this.wire(wire);\n\n    }\n\n    wire(wire) {\n\n        wire.target = this._frames[0];\n        this._wires.push(wire);\n        return this;\n\n    }\n\n    monitor(data, name){\n\n        const wire = Wire.fromMonitor(data, name);\n        wire.target = this._frames[0];\n        this._wires.push(wire);\n\n        return this;\n\n    };\n\n\n    scan(func, seed){\n\n        return this.reduce(F.getScan, func, seed);\n\n    };\n\n    delay(fNum) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('delay', F.FUNCTOR(fNum)));\n        return this;\n\n    };\n\n    willReset(){\n\n        F.ASSERT_IS_HOLDING(this);\n        return this.clear(F.getAlwaysTrue);\n\n    }\n\n    whenKeys(keys) {\n\n        return this.when(F.getWhenKeys, true, keys);\n\n    };\n\n    group(by) {\n\n        this.reduce(F.getGroup, by);\n        return this;\n\n    };\n\n    groupByTopic() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.hold().reduce(F.getGroup, F.TO_TOPIC);\n        return this;\n    };\n\n    all() {\n        return this.reduce(F.getKeepAll);\n    };\n\n    first(n) {\n        return this.reduce(F.getKeepFirst, n);\n    };\n\n    last(n) {\n        return this.reduce(F.getKeepLast, n);\n    };\n\n    clear(factory, ...args) {\n        return this._currentFrame.clear(factory, ...args);\n    };\n\n    reduce(factory, ...args) {\n\n        const holding = this.holding;\n\n        if(!holding){\n\n            const frame = this.addFrame();\n            const def = new WaveDef('msg', factory, true, ...args);\n            frame.define(def);\n\n        } else {\n\n            const frame = this._currentFrame;\n            const def = frame._processDef;\n            def.keep = [factory, true, ...args];\n\n        }\n\n        return this;\n\n    };\n\n    timer(factory, stateful, ...args) {\n\n        const holding = this.holding;\n        const frame = holding ? this._currentFrame : this.addFrame().hold();\n        const def = frame._processDef;\n        def.timer = [factory, stateful, ...args];\n        this._currentFrame._holding = false; // timer ends hold\n\n        return this;\n\n    };\n\n    until(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.until(factory, ...args) :\n            this.addFrame().hold().reduce(F.getKeepLast).until(factory, ...args).timer(F.getSyncTimer);\n        return this;\n\n    };\n\n    when(factory, stateful, ...args) {\n\n        const holding = this.holding;\n\n        if(!holding){\n\n            const frame = this.addFrame();\n            const def = new WaveDef('filter', factory, stateful, ...args);\n            frame.define(def);\n\n        } else {\n\n            const frame = this._currentFrame;\n            const def = frame._processDef;\n            def.when = [factory, stateful, ...args];\n\n        }\n\n        return this;\n\n    };\n\n    run(func) {\n\n        F.ASSERT_IS_FUNCTION(func);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('run', func));\n        return this;\n\n    };\n\n    merge() {\n\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().merge();\n        return this;\n    };\n\n    msg(fAny) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('msg', F.FUNCTOR(fAny)));\n        return this;\n\n    };\n\n    transform(fAny) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().transform(fAny);\n        return this;\n\n    };\n\n    source(fStr) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('source', F.FUNCTOR(fStr)));\n        return this;\n\n    };\n\n\n    filter(func) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_IS_FUNCTION(func);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('filter', func));\n        return this;\n\n\n    };\n\n    hasKeys(keys) {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().define(new WaveDef('filter', F.getHasKeys(keys)));\n        return this;\n\n    };\n\n    skipDupes() {\n\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().define(new WaveDef('filter', F.getSkipDupes, true));\n        return this;\n\n    };\n\n    toStream() {\n        // merge, fork -> immutable stream?\n    };\n\n    destroy() {\n\n        if (this.dead)\n            return this;\n\n        this._dead = true;\n\n        const wires = this._wires;\n        const len = wires.length;\n        for (let i = 0; i < len; i++) {\n            const wire = wires[i];\n            wire.destroy();\n        }\n\n        this._wires = null;\n        return this;\n\n    };\n\n}\n\n\n\nexport default Bus;\n","\n\nconst Nyan = {};\n\n// then = applies to all words in a phrase\n// watch: ^ = action, need, event, watch | read, must\n// then:  run, read, attr, and, style, write, blast, filter\n\nconst operationDefs = [\n\n    {name: 'ACTION', sym: '^',  react: true, subscribe: true, need: true, solo: true},\n    {name: 'WIRE',   sym: '~',  react: true, follow: true}, // INTERCEPT\n    {name: 'WATCH',  sym: null, react: true, follow: true},\n    {name: 'EVENT',  sym: '@',  react: true, event: true},\n    {name: 'ALIAS',  sym: '(',  then: true, solo: true},\n    {name: 'METHOD', sym: '`',  then: true, solo: true},\n    {name: 'READ',   sym: null, then: true, read: true},\n    {name: 'ATTR',   sym: '#',  then: true, solo: true, output: true},\n    {name: 'AND',    sym: '&',  then: true },\n    {name: 'STYLE',  sym: '$',  then: true,  solo: true, output: true },\n    {name: 'WRITE',  sym: '=',  then: true,  solo: true },\n    {name: 'SPRAY',  sym: '<',  then: true },\n    {name: 'RUN',    sym: '*',  then: true, output: true },\n    {name: 'FILTER', sym: '>',  then: true }\n\n];\n\n// cat, dog | & meow, kitten {*log} | =puppy\n\n\n// todo make ! a trailing thingie, must goes away\n// trailing defs -- ! = needs message in data to continue, ? = data must exist or throw error\n// {name: 'BEGIN',  sym: '{'}, -- fork\n// {name: 'END',    sym: '}'}, -- back\n// {name: 'PIPE',   sym: '|'}, -- phrase delimiter\n// read = SPACE\n// - is data maybe (data point might not be present)\n// ? is object maybe (object might not be there)\n// () is rename\n\nconst operationsBySymbol = {};\nconst operationsByName = {};\nconst symbolsByName = {};\nconst namesBySymbol = {};\nconst reactionsByName = {};\nconst withReactionsByName = {};\nconst thenByName = {};\n\nfor(let i = 0; i < operationDefs.length; i++){\n\n    const op = operationDefs[i];\n    const name = op.name;\n    const sym = op.sym;\n\n    if(sym) {\n        operationsBySymbol[sym] = op;\n        namesBySymbol[sym] = name;\n    }\n\n    operationsByName[name] = op;\n    symbolsByName[name] = sym;\n\n    if(op.then){\n        thenByName[name] = true;\n    }\n\n    if(op.react) {\n        reactionsByName[name] = true;\n        withReactionsByName[name] = true;\n    }\n\n}\n\n\n\nclass NyanWord {\n\n    constructor(name, operation, maybe, need, topic, alias, monitor, extracts){\n\n        this.name = name;\n        this.operation = operation;\n        this.maybe = maybe || false;\n        this.need = need || false;\n        this.topic = topic || null;\n        this.alias = alias || null;\n        this.monitor = monitor || false;\n        this.extracts = extracts && extracts.length ? extracts : null; // possible list of message property pulls\n        // this.useCapture =\n\n    }\n\n}\n\nlet tickStack = [];\n\nfunction toTickStackString(str){\n\n\n    tickStack = [];\n    const chunks = str.split(/([`])/);\n    const strStack = [];\n\n    let ticking = false;\n    while(chunks.length){\n        const c = chunks.shift();\n        if(c === '`'){\n            ticking = !ticking;\n            strStack.push(c);\n        } else {\n            if(ticking) {\n                tickStack.push(c);\n            } else {\n                strStack.push(c);\n            }\n        }\n    }\n\n    const result = strStack.join('');\n    //console.log('stack res', result, tickStack);\n    return result;\n}\n\nfunction parse(str, isProcess) {\n\n\n    str = toTickStackString(str);\n\n    const sentences = [];\n\n    // split on curlies and remove empty chunks (todo optimize for parsing speed, batch loop operations?)\n    let chunks = str.split(/([{}]|-})/).map(d => d.trim()).filter(d => d);\n\n    for(let i = 0; i < chunks.length; i++){\n\n        const chunk = chunks[i];\n        const sentence = (chunk === '}' || chunk === '{' || chunk === '-}') ? chunk : parseSentence(chunk);\n\n        if(typeof sentence === 'string' || sentence.length > 0)\n            sentences.push(sentence);\n\n    }\n\n    return validate(sentences, isProcess);\n\n\n}\n\nfunction validate(sentences, isProcess){\n\n    const cmdList = [];\n    let firstPhrase = true;\n    \n    for(let i = 0; i < sentences.length; i++){\n        const s = sentences[i];\n        if(typeof s !== 'string') {\n\n            for (let j = 0; j < s.length; j++) {\n                const phrase = s[j];\n                if(firstPhrase && !isProcess) {\n                    validateReactPhrase(phrase);\n                    firstPhrase = false;\n                    cmdList.push({name: 'REACT', phrase: phrase});\n                }\n                else {\n                    validateProcessPhrase(phrase);\n                    cmdList.push({name: 'PROCESS', phrase: phrase});\n                }\n            }\n\n        } else if (s === '{') {\n            cmdList.push({name: 'FORK'});\n        } else if (s === '}') {\n            cmdList.push({name: 'BACK'});\n        } else if (s === '-}') {\n            cmdList.push({name: 'JOIN'});\n        }\n    }\n\n    return cmdList;\n}\n\n\nfunction validateReactPhrase(phrase){\n\n    let hasReaction = false;\n    for(let i = 0; i < phrase.length; i++){\n\n        const nw = phrase[i];\n        const operation = nw.operation = nw.operation || 'WATCH';\n        hasReaction = hasReaction || reactionsByName[operation];\n        if(!withReactionsByName[operation])\n            throw new Error('This Nyan command cannot be in a reaction!');\n\n    }\n\n    if(!hasReaction)\n        throw new Error('Nyan commands must begin with an observation!');\n\n}\n\n\n\nfunction validateProcessPhrase(phrase){\n\n    const firstPhrase = phrase[0];\n    const firstOperation = firstPhrase.operation || 'READ';\n\n    if(!thenByName[firstOperation])\n        throw new Error('Illegal operation in phrase!'); // unknown or reactive\n\n    for(let i = 0; i < phrase.length; i++){\n\n        const nw = phrase[i];\n        nw.operation = nw.operation || firstOperation;\n        if(nw.operation !== firstOperation){\n\n           // console.log('mult', nw.operation, firstOperation);\n            throw new Error('Multiple operation types in phrase (only one allowed)!');\n\n        }\n\n    }\n\n}\n\n\n\nfunction parseSentence(str) {\n\n    const result = [];\n    const chunks = str.split('|').map(d => d.trim()).filter(d => d);\n\n    for(let i = 0; i < chunks.length; i++){\n\n        const chunk = chunks[i];\n        const phrase = parsePhrase(chunk);\n        result.push(phrase);\n\n    }\n\n    return result;\n\n}\n\nfunction parsePhrase(str) {\n\n    const words = [];\n    const rawWords = str.split(',').map(d => d.trim()).filter(d => d);\n\n    const len = rawWords.length;\n\n    for (let i = 0; i < len; i++) {\n\n        const rawWord = rawWords[i];\n        //console.log('word=', rawWord);\n        const rawChunks = rawWord.split(/([(?!:.`)])/);\n        const chunks = [];\n        let inMethod = false;\n\n        // white space is only allowed between e.g. `throttle 200`, `string meow in the hat`\n\n        while(rawChunks.length){\n            const next = rawChunks.shift();\n            if(next === '`'){\n                inMethod = !inMethod;\n                chunks.push(next);\n            } else {\n                if(!inMethod){\n                    const trimmed = next.trim();\n                    if(trimmed)\n                        chunks.push(trimmed);\n                } else {\n                    chunks.push(next);\n                }\n            }\n        }\n\n        //console.log('to:', chunks);\n        const nameAndOperation = chunks.shift();\n        const firstChar = rawWord[0];\n        const operation = namesBySymbol[firstChar];\n        const start = operation ? 1 : 0;\n        const name = nameAndOperation.slice(start).trim();\n        const extracts = [];\n\n        // todo hack (rename)\n\n        let maybe = false;\n        let monitor = false;\n        let topic = null;\n        let alias = null;\n        let need = false;\n\n        if(operation === 'ALIAS'){\n            alias = chunks.shift();\n            chunks.shift(); // todo verify ')'\n        } else if (operation === 'METHOD'){\n                chunks.shift();\n                // const next = chunks.shift();\n                const next = tickStack.shift();\n                const i = next.indexOf(' ');\n                if(i === -1) {\n                    extracts.push(next);\n                } else {\n                    extracts.push(next.slice(0, i));\n                    if(next.length > i){\n                        extracts.push(next.slice(i + 1));\n                    }\n                }\n\n            while(chunks.length){ chunks.shift(); }\n        }\n\n        while(chunks.length){\n\n            const c = chunks.shift();\n\n            switch(c){\n\n                case '.':\n\n                    const prop = chunks.length && chunks[0]; // todo assert not operation\n                    const silentFail = chunks.length > 1 && (chunks[1] === '?');\n\n                    if(prop) {\n                        extracts.push({name: prop, silentFail: silentFail});\n                        chunks.shift(); // remove word from queue\n                        if(silentFail)\n                            chunks.shift(); // remove ? from queue\n                    }\n\n                    break;\n\n                case '?':\n\n                    maybe = true;\n                    break;\n\n                case '!':\n\n                    need = true;\n                    break;\n\n                case ':':\n\n                    if(chunks.length){\n                        const next = chunks[0];\n                        if(next === '('){\n                            monitor = true;\n                        } else {\n                            topic = next;\n                            chunks.shift(); // remove topic from queue\n                        }\n                    } else {\n                        monitor = true;\n                    }\n\n                    break;\n\n                case '(':\n\n                    if(chunks.length){\n                        alias = chunks.shift(); // todo assert not operation\n                    }\n\n                    break;\n\n\n\n            }\n\n        }\n\n        alias = alias || topic || name;\n        const nw = new NyanWord(name, operation, maybe, need, topic, alias, monitor, extracts);\n        words.push(nw);\n\n    }\n\n    return words;\n\n}\n\nNyan.parse = parse;\n\n\nexport default Nyan;\n\n","import Wire from './wire.js';\nimport Nyan from './nyan.js';\n\n\nfunction getPacketFromDataWord(scope, word){\n\n    const data = scope.find(word.name, !word.maybe);\n    const peek = data && data.peek(word.topic);\n    return peek;\n\n}\n\n\nfunction getSurveyFromDataWord(scope, word){\n\n    const data = scope.find(word.name, !word.maybe);\n    return data && data.survey();\n\n}\n\nfunction throwError(msg){\n    console.log('throwing ', msg);\n    const e = new Error(msg);\n    console.log(this, e);\n    throw e;\n}\n\nfunction getDoSkipNamedDupes(names){\n\n    let lastMsg = {};\n    const len = names.length;\n\n    return function doSkipNamedDupes(msg) {\n\n        let diff = false;\n        for(let i = 0; i < len; i++){\n            const name = names[i];\n            if(!lastMsg.hasOwnProperty(name) || lastMsg[name] !== msg[name])\n                diff = true;\n            lastMsg[name] = msg[name];\n        }\n\n        return diff;\n\n    };\n}\n\n\nfunction getDoWrite(scope, word){\n\n    const data = scope.find(word.name, !word.maybe);\n\n    return function doWrite(msg) {\n        data.write(msg, word.topic);\n    };\n\n}\n\n\nfunction getDoSpray(scope, phrase){\n\n    const wordByAlias = {};\n    const dataByAlias = {};\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++){ // todo, validate no dupe alias in word validator for spray\n\n        const word = phrase[i];\n        const data = scope.find(word.name, !word.maybe);\n        if(data) { // might not exist if optional\n            wordByAlias[word.alias] = word;\n            dataByAlias[word.alias] = data;\n        }\n\n    }\n\n    return function doWrite(msg) {\n\n        for(const alias in msg){\n\n            const data = dataByAlias[alias];\n            if(data) {\n                const word = wordByAlias[alias];\n                const msgPart = msg[alias];\n                data.silentWrite(msgPart, word.topic);\n            }\n\n        }\n\n        for(const alias in msg){\n\n            const data = dataByAlias[alias];\n            if(data) {\n                const word = wordByAlias[alias];\n                data.refresh(word.topic);\n            }\n\n        }\n\n\n    };\n\n\n}\n\n\nfunction getDoRead(scope, phrase){\n\n    const len = phrase.length;\n    const firstWord = phrase[0];\n\n    if(len > 1 || firstWord.monitor) { // if only reading word is a wildcard subscription then hash as well\n        return getDoReadMultiple(scope, phrase);\n    } else {\n        return getDoReadSingle(scope, firstWord);\n    }\n\n}\n\n\nfunction getDoAnd(scope, phrase) {\n\n    return getDoReadMultiple(scope, phrase, true);\n\n}\n\n\nfunction getDoReadSingle(scope, word) {\n\n    return function doReadSingle() {\n\n        const packet = getPacketFromDataWord(scope, word);\n        return packet && packet.msg;\n\n    };\n\n}\n\n\nfunction getDoReadMultiple(scope, phrase, isAndOperation){\n\n\n        const len = phrase.length;\n\n\n        return function doReadMultiple(msg, source) {\n\n            const result = {};\n\n            if(isAndOperation){\n\n                if(source){\n                    result[source] = msg;\n                } else {\n                    for (const p in msg) {\n                        result[p] = msg[p];\n                    }\n                }\n            }\n\n            for (let i = 0; i < len; i++) {\n                const word = phrase[i];\n\n                if(word.monitor){\n\n                    const survey = getSurveyFromDataWord(scope, word);\n                    for(const [key, value] of survey){\n                        result[key] = value;\n                    }\n\n                } else {\n\n                    const packet = getPacketFromDataWord(scope, word);\n                    const prop = word.monitor ? (word.alias || word.topic) : (word.alias || word.name);\n                    if (packet)\n                        result[prop] = packet.msg;\n\n                }\n\n            }\n\n            return result;\n\n        };\n\n}\n\n\n// get data stream -- store data in bus, emit into stream on pull()\n\n\nfunction getDataWire(scope, word, canPull) {\n\n    const data = scope.find(word.name, !word.maybe);\n    if(word.monitor){\n        return Wire.fromMonitor(data, word.alias, canPull);\n    } else {\n        return Wire.fromSubscribe(data, word.topic, word.alias, canPull);\n    }\n\n}\n\nfunction isObject(v) {\n    if (v === null)\n        return false;\n    return (typeof v === 'function') || (typeof v === 'object');\n}\n\n\nfunction getEventWire(word, target){\n\n    return Wire.fromEvent(target, word.topic, word.useCapture, word.alias);\n\n}\n\nfunction doExtracts(value, extracts) {\n\n    let result = value;\n    const len = extracts.length;\n\n    for (let i = 0; i < len; i++) {\n        const extract = extracts[i];\n        if(!isObject(result)) {\n            if(extract.silentFail)\n                return undefined;\n\n            throwError('Cannot access property \\'' + extract.name + '\\' of ' + result);\n\n        }\n        result = result[extract.name];\n    }\n\n\n    return result;\n\n}\n\nfunction getNeedsArray(phrase){\n    return phrase.filter(word => word.operation.need).map(word => word.alias);\n}\n\nfunction getDoMsgHashExtract(words) {\n\n    const len = words.length;\n    const extractsByAlias = {};\n\n    for (let i = 0; i < len; i++) {\n\n        const word = words[i];\n        extractsByAlias[word.alias] = word.extracts;\n\n    }\n\n    return function(msg) {\n\n        const result = {};\n        for(const alias in extractsByAlias){\n            const hasProp = msg.hasOwnProperty(alias);\n            if(hasProp){\n                result[alias] = doExtracts(msg[alias], extractsByAlias[alias]);\n            }\n        }\n\n        return result;\n\n    };\n\n}\n\nfunction getDoMsgExtract(word) {\n\n    const extracts = word.extracts;\n\n    return function(msg){\n        return doExtracts(msg, extracts);\n    }\n\n}\n\n\nfunction applyReaction(scope, bus, phrase, target) { // target is some event emitter\n\n    const need = [];\n    const skipDupes = [];\n    const streams = [];\n    const extracts = [];\n\n    if(phrase.length === 1 && phrase[0].operation === 'ACTION'){\n        const word = phrase[0];\n        bus.wire(getDataWire(scope, word, false));\n        return;\n    }\n\n    for(let i = 0; i < phrase.length; i++){\n\n        const word = phrase[i];\n        const operation = word.operation;\n\n        if(operation === 'WATCH') {\n            bus.wire(getDataWire(scope, word, true));\n            skipDupes.push(word.alias)\n        }\n        else if(operation === 'WIRE'){\n            bus.wire(getDataWire(scope, word, true));\n        }\n        else if(operation === 'EVENT') {\n            bus.wire(getEventWire(word, target));\n        }\n\n        if(word.extracts)\n            extracts.push(word);\n\n        if(word.need)\n            need.push(word.alias);\n\n    }\n\n    // transformations are applied via named hashes for performance\n\n    if(bus._wires.length > 1) {\n\n        bus.merge().group().batch();\n\n        if(extracts.length)\n            bus.msg(getDoMsgHashExtract(extracts));\n\n        if(need.length)\n            bus.hasKeys(need);\n\n        if(skipDupes.length){\n            bus.filter(getDoSkipNamedDupes(skipDupes));\n        }\n\n    } else {\n\n        if(extracts.length)\n            bus.msg(getDoMsgExtract(extracts[0]));\n\n        if(skipDupes.length)\n            bus.skipDupes();\n\n    }\n\n}\n\nfunction isTruthy(msg){\n    return !!msg;\n}\n\nfunction isFalsey(msg){\n    return !msg;\n}\n\n\nfunction applyMethod(bus, word) {\n\n    const method = word.extracts[0];\n\n    switch(method){\n\n        case 'true':\n            bus.msg(true);\n            break;\n\n        case 'false':\n            bus.msg(false);\n            break;\n\n        case 'null':\n            bus.msg(null);\n            break;\n\n        case 'undefined':\n            bus.msg(undefined);\n            break;\n\n        case 'array':\n            bus.msg([]);\n            break;\n\n        case 'object':\n            bus.msg({});\n            break;\n\n        case 'truthy':\n            bus.filter(isTruthy);\n            break;\n\n        case 'falsey':\n            bus.filter(isFalsey);\n            break;\n\n        case 'string':\n            bus.msg(function(){ return word.extracts[1];});\n            break;\n\n            // throttle x, debounce x, delay x, last x, first x, all\n\n    }\n\n}\n\nfunction applyProcess(scope, bus, phrase, context, node) {\n\n    const operation = phrase[0].operation; // same for all words in a process phrase\n\n    if(operation === 'READ') {\n        bus.msg(getDoRead(scope, phrase));\n        const needs = getNeedsArray(phrase);\n        if(needs.length)\n            bus.whenKeys(needs);\n    } else if (operation === 'AND') {\n        bus.msg(getDoAnd(scope, phrase));\n        const needs = getNeedsArray(phrase);\n        if (needs.length)\n            bus.whenKeys(needs);\n    } else if (operation === 'METHOD') {\n        applyMethod(bus, phrase[0]);\n    } else if (operation === 'FILTER') {\n        applyFilterProcess(bus, phrase, context);\n    } else if (operation === 'RUN') {\n        applyMsgProcess(bus, phrase, context);\n    } else if (operation === 'ALIAS') {\n        applySourceProcess(bus, phrase[0]);\n    } else if (operation === 'WRITE') {\n        bus.run(getDoWrite(scope, phrase[0]));\n    } else if (operation === 'SPRAY') {\n        bus.run(getDoSpray(scope, phrase)); // todo validate that writes do not contain words in reacts\n\n    }\n\n}\n\n\n\nfunction applyMsgProcess(bus, phrase, context){\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++) {\n\n        const word = phrase[i];\n        const name = word.name;\n        const method = context[name];\n\n        const f = function (msg, source, topic) {\n            return method.call(context, msg, source, topic);\n        };\n\n        bus.msg(f);\n\n    }\n\n}\n\n\nfunction applyRunProcess(bus, phrase, context){\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++) {\n\n        const word = phrase[i];\n        const name = word.name;\n        const method = context[name];\n\n        const f = function (msg, source, topic) {\n            return method.call(context, msg, source, topic);\n        };\n\n        bus.run(f);\n\n    }\n\n}\n\nfunction applySourceProcess(bus, word){\n\n    bus.source(word.alias);\n\n}\n\n\nfunction applyFilterProcess(bus, phrase, context){\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++) {\n\n        const word = phrase[i];\n        const name = word.name;\n        const method = context[name];\n\n        const f = function (msg, source, topic) {\n            return method.call(context, msg, source, topic);\n        };\n\n        bus.filter(f);\n\n    }\n\n}\n\n\nfunction nyanToBus(scope, bus, str, context, target){\n\n    const nyan = Nyan.parse(str);\n    const len = nyan.length;\n\n    for(let i = 0; i < len; i++){\n\n        const cmd = nyan[i];\n        const name = cmd.name;\n        const phrase = cmd.phrase;\n\n      //  console.log('----', name, phrase);\n\n        if(name === 'JOIN') {\n            bus = bus.join();\n            bus.merge();\n            bus.group();\n            bus.sync();\n        } else if(name === 'FORK'){\n            bus = bus.fork();\n        } else if (name === 'BACK'){\n            bus = bus.back();\n        } else {\n\n            if(name === 'PROCESS')\n                applyProcess(scope, bus, phrase, context, target);\n            else // name === 'REACT'\n                applyReaction(scope, bus, phrase, target);\n\n        }\n    }\n\n    return bus;\n\n}\n\nexport default nyanToBus;","\n\nimport Data from './data.js';\nimport { DATA_TYPES } from './dataTypes.js';\nimport Bus from './bus.js';\nimport nyanToBus from './nyanBus.js';\n\nlet idCounter = 0;\n\nfunction _destroyEach(arr){\n\n    const len = arr.length;\n    for(let i = 0; i < len; i++){\n        const item = arr[i];\n        item.destroy();\n    }\n\n}\n\n\nclass Scope{\n\n    constructor(name) {\n\n        this._id = ++idCounter;\n        this._name = name;\n        this._parent = null;\n        this._children = [];\n        this._busList = [];\n        this._dataList = new Map();\n        this._valves = new Map();\n        this._mirrors = new Map();\n        this._dead = false;\n\n    };\n\n    get name() { return this._name; };\n    get dead() { return this._dead; };\n\n    get children(){\n\n        return this._children.map((d) => d);\n\n    };\n\n\n    // todo react via nyan (so it can be precompiled and reused\n    react(str, context, node){ // string is Nyan\n\n        if(!str)\n            throw new Error('Need a Nyan phrase!');\n\n        let b = new Bus(this);\n\n        return nyanToBus(this, b, str, context, node);\n\n    };\n\n    clear(){\n\n        if(this._dead)\n            return;\n\n        _destroyEach(this.children); // iterates over copy to avoid losing position as children leaves their parent\n        _destroyEach(this._busList);\n        _destroyEach(this._dataList.values());\n\n        this._children = [];\n        this._busList = [];\n        this._dataList.clear();\n        this._valves.clear();\n        this._mirrors.clear();\n\n    };\n\n    destroy(){\n\n        this.clear();\n        this.parent = null;\n        this._dead = true;\n\n    };\n\n    createChild(name){\n\n        let child = new Scope(name);\n        child.parent = this;\n        return child;\n\n    };\n\n    insertParent(newParent){\n\n        newParent.parent = this.parent;\n        this.parent = newParent;\n        return this;\n\n    };\n\n    get parent() { return this._parent; };\n\n    set parent(newParent){\n\n        const oldParent = this.parent;\n\n        if(oldParent === newParent)\n            return;\n\n        if(oldParent) {\n            const i = oldParent._children.indexOf(this);\n            oldParent._children.splice(i, 1);\n        }\n\n        this._parent = newParent;\n\n        if(newParent) {\n            newParent._children.push(this);\n        }\n\n        return this;\n\n    };\n\n    set valves(list){\n\n        for(const name of list){\n            this._valves.set(name, true);\n        }\n\n    }\n\n    get valves(){ return Array.from(this._valves.keys());};\n\n\n    _createMirror(data){\n\n        const mirror = Object.create(data);\n        mirror._type = DATA_TYPES.MIRROR;\n        this._mirrors.set(data.name, mirror);\n        return mirror;\n\n    };\n\n    _createData(name, type){\n\n        const d = new Data(this, name, type);\n        this._dataList.set(name, d);\n        return d;\n\n    };\n\n\n    data(name){\n\n        return this.grab(name) || this._createData(name, DATA_TYPES.NONE);\n\n    };\n\n\n    action(name){\n\n        const d = this.grab(name);\n\n        if(d)\n            return d.verify(DATA_TYPES.ACTION);\n\n        return this._createData(name, DATA_TYPES.ACTION);\n\n    };\n\n\n    state(name){\n\n        const d = this.grab(name);\n\n        if(d)\n            return d.verify(DATA_TYPES.STATE);\n\n        const state = this._createData(name, DATA_TYPES.STATE);\n        this._createMirror(state);\n        return state;\n\n    };\n\n\n    findDataSet(names, required){\n\n\n        const result = {};\n        for(const name of names){\n            result[name] = this.find(name, required);\n        }\n\n        return result;\n\n    };\n\n    readDataSet(names, required){\n\n        const dataSet = this.findDataSet(names, required);\n        const result = {};\n\n        for(const d of dataSet) {\n            if (d) {\n                const lastPacket = d.peek();\n                if (lastPacket)\n                    result[d.name] = lastPacket.msg;\n            }\n        }\n\n        return result;\n    };\n\n\n    // created a flattened view of all data at and above this scope\n\n    flatten(){\n\n        let scope = this;\n\n        const result = new Map();\n        const appliedValves = new Map();\n\n        for(const [key, value] of scope._dataList){\n            result.set(key, value);\n        }\n\n        while(scope = scope._parent){\n\n            const dataList = scope._dataList;\n            const valves = scope._valves;\n            const mirrors = scope._mirrors;\n\n            if(!dataList.size)\n                continue;\n\n            // further restrict valves with each new scope\n\n            if(valves.size){\n                if(appliedValves.size) {\n                    for (const key of appliedValves.keys()) {\n                        if(!valves.has(key))\n                            appliedValves.delete(key);\n                    }\n                } else {\n                    for (const [key, value] of valves.entries()) {\n                        appliedValves.set(key, value);\n                    }\n                }\n            }\n\n            const possibles = appliedValves.size ? appliedValves : dataList;\n\n            for(const key of possibles.keys()) {\n                if (!result.has(key)) {\n\n                    const data = mirrors.get(key) || dataList.get(key);\n                    if (data)\n                        result.set(key, data);\n                }\n            }\n\n        }\n\n        return result;\n\n    };\n\n\n    find(name, required){\n\n        const localData = this.grab(name);\n        if(localData)\n            return localData;\n\n        let scope = this;\n\n        while(scope = scope._parent){\n\n            const valves = scope._valves;\n\n            // if valves exist and the name is not present, stop looking\n            if(valves.size && !valves.has(name)){\n                break;\n            }\n\n            const mirror = scope._mirrors.get(name);\n\n            if(mirror)\n                return mirror;\n\n            const d = scope.grab(name);\n\n            if(d)\n                return d;\n\n        }\n\n        if(required)\n            throw new Error('Required data: ' + name + ' not found!');\n\n        return null;\n\n    };\n\n    findOuter(name, required){\n\n        let foundInner = false;\n        const localData = this.grab(name);\n        if(localData)\n            foundInner = true;\n\n        let scope = this;\n\n        while(scope = scope._parent){\n\n            const valves = scope._valves;\n\n            // if valves exist and the name is not present, stop looking\n            if(valves.size && !valves.has(name)){\n                break;\n            }\n\n            const mirror = scope._mirrors.get(name);\n\n            if(mirror) {\n\n                if(foundInner)\n                    return mirror;\n\n                foundInner = true;\n                continue;\n            }\n\n            const d = scope.grab(name);\n\n            if(d) {\n\n                if(foundInner)\n                    return d;\n\n                foundInner = true;\n            }\n\n        }\n\n        if(required)\n            throw new Error('Required data: ' + name + ' not found!');\n\n        return null;\n\n    };\n\n    grab(name, required) {\n\n        const data = this._dataList.get(name);\n\n        if(!data && required)\n            throw new Error('Required Data: ' + name + ' not found!');\n\n        return data || null;\n\n    };\n\n    transaction(writes){\n\n        if(Array.isArray(writes))\n            return this._multiWriteArray(writes);\n        else if(typeof writes === 'object')\n            return this._multiWriteHash(writes);\n\n        throw new Error('Write values must be in an array of object hash.');\n\n    };\n\n    // write {name, topic, value} objects as a transaction\n    _multiWriteArray(writeArray){\n\n        const list = [];\n\n        for(const w of writeArray){\n            const d = this.find(w.name);\n            d.silentWrite(w.value, w.topic);\n            list.push(d);\n        }\n\n        let i = 0;\n        for(const d of list){\n            const w = writeArray[i];\n            d.refresh(w.topic);\n        }\n\n        return this;\n\n    };\n\n\n    // write key-values as a transaction\n    _multiWriteHash(writeHash){\n\n        const list = [];\n\n        for(const k in writeHash){\n            const v = writeHash[k];\n            const d = this.find(k);\n            d.silentWrite(v);\n            list.push(d);\n        }\n\n        for(const d of list){\n            d.refresh();\n        }\n\n        return this;\n\n    };\n\n}\n\nexport default Scope;\n","\nimport Scope from './scope.js';\nimport Wire from './wire.js';\nimport Bus from './bus.js';\n\n\nconst Catbus = {};\n\nlet _batchQueue = [];\nlet _primed = false;\n\nCatbus.bus = function(){\n    return new Bus();\n};\n\n\nCatbus.fromEvent = function(target, eventName, useCapture){\n\n    const bus = new Bus();\n    bus.event(target, eventName, useCapture);\n    return bus;\n\n};\n\n// todo stable output queue -- output pools go in a queue that runs after the batch q is cleared, thus run once only\n\nCatbus.enqueue = function(pool){\n\n    _batchQueue.push(pool);\n\n    if(!_primed) { // register to flush the queue\n        _primed = true;\n        if (typeof window !== 'undefined' && window.requestAnimationFrame) requestAnimationFrame(Catbus.flush);\n        else process.nextTick(Catbus.flush);\n    }\n\n};\n\n\nCatbus.createChild = Catbus.scope = function(name){\n\n    return new Scope(name);\n\n};\n\n\nCatbus.flush = function(){\n\n    _primed = false;\n\n    let cycles = 0;\n    let q = _batchQueue;\n    _batchQueue = [];\n\n    while(q.length) {\n\n        while (q.length) {\n            const pool = q.shift();\n            pool.release();\n        }\n\n        q = _batchQueue;\n        _batchQueue = [];\n\n        cycles++;\n        if(cycles > 10)\n            throw new Error('Flush batch cycling loop > 10.', q);\n\n    }\n\n};\n\n\n\nexport default Catbus;\n","\nimport Catbus from './catbus.js';\n\nexport default Catbus;\n\n// export default () => {\n//     let s = new Scope('cow');\n//     return s;\n// }"],"names":["Packet","msg","topic","source","_msg","_topic","_source","_timestamp","Date","now","DATA_TYPES","reverseLookup","p","v","isValid","type","hasOwnProperty","SubscriberList","data","_subscribers","_lastPacket","_data","_name","_dead","silently","dead","name","currentPacket","ACTION","subscribers","concat","len","length","i","s","call","handle","watcher","push","indexOf","splice","Data","scope","NONE","Error","_scope","_type","_wildcardSubscriberList","_subscriberListsByTopic","Map","_throwDead","values","list","destroy","undefined","get","set","expectedType","subscribe","packet","peek","_demandSubscriberList","add","remove","keys","entries","m","key","value","lastPacket","subscriberList","write","MIRROR","read","pass","frame","wire","emit","Wave","def","process","action","stateful","args","callback","ALWAYS_TRUE","ALWAYS_FALSE","TO_SOURCE","TO_TOPIC","TO_MSG","NOOP","FUNCTOR","val","Func","func","pool","enqueue","release","fNum","wasEmpty","timeoutId","msgDuringTimer","auto","keep","timedRelease","fromTimeout","stream","nowEmpty","isEmpty","setTimeout","n","Infinity","buffer","f","isBuffer","next","shift","content","seed","hasSeed","arguments","acc","initMsg","reset","groupBy","hash","g","k","last","firstMsg","hasFirst","latched","messages","keyHash","messagesByKey","noLatch","hadMsg","lastMsg","diff","bus","holding","To_MSG","Pool","fromDef","factory","F","getKeepLast","when","until","timer","clear","isPrimed","prop","hasContent","PoolDef","Wire","target","cleanupMethod","pull","fromInterval","delay","toWire","id","setInterval","fromMonitor","unsubscribe","monitor","fromSubscribe","canPull","fromEvent","eventName","useCapture","on","addEventListener","addListener","off","removeEventListener","removeListener","Frame","_bus","_targets","_index","_frames","_wireMap","WeakMap","_holding","_processDef","_mergingWire","hasWire","has","_createHandler","handler","WaveDef","Bus","_wires","_children","_parent","_busList","_currentFrame","lastFrame","nextFrame","ASSERT_NOT_HOLDING","fork","parent","back","addFrame","getDeferTimer","getBatchTimer","getSyncTimer","getThrottleTimer","hold","reduce","getScan","ASSERT_NEED_ONE_ARGUMENT","define","ASSERT_IS_HOLDING","getAlwaysTrue","getWhenKeys","by","getGroup","getKeepAll","getKeepFirst","ASSERT_IS_FUNCTION","merge","fAny","transform","fStr","getHasKeys","getSkipDupes","wires","map","d","newParent","oldParent","Nyan","operationDefs","sym","react","need","solo","follow","event","then","output","operationsBySymbol","operationsByName","symbolsByName","namesBySymbol","reactionsByName","withReactionsByName","thenByName","op","NyanWord","operation","maybe","alias","extracts","tickStack","toTickStackString","str","chunks","split","strStack","ticking","c","result","join","parse","isProcess","sentences","trim","filter","chunk","sentence","parseSentence","validate","cmdList","firstPhrase","j","phrase","validateReactPhrase","hasReaction","nw","validateProcessPhrase","firstOperation","parsePhrase","words","rawWords","rawWord","rawChunks","inMethod","trimmed","nameAndOperation","firstChar","start","slice","silentFail","getPacketFromDataWord","word","find","getSurveyFromDataWord","survey","throwError","log","e","getDoSkipNamedDupes","names","doSkipNamedDupes","getDoWrite","doWrite","getDoSpray","wordByAlias","dataByAlias","msgPart","silentWrite","refresh","getDoRead","firstWord","getDoReadMultiple","getDoReadSingle","getDoAnd","doReadSingle","isAndOperation","doReadMultiple","getDataWire","isObject","getEventWire","doExtracts","extract","getNeedsArray","getDoMsgHashExtract","extractsByAlias","hasProp","getDoMsgExtract","applyReaction","skipDupes","streams","group","batch","hasKeys","isTruthy","isFalsey","applyMethod","method","applyProcess","context","node","needs","whenKeys","run","applyMsgProcess","applySourceProcess","applyFilterProcess","nyanToBus","nyan","cmd","sync","idCounter","_destroyEach","arr","item","Scope","_id","_dataList","_valves","_mirrors","b","children","child","mirror","Object","create","grab","_createData","verify","STATE","state","_createMirror","required","dataSet","findDataSet","appliedValves","dataList","valves","mirrors","size","delete","possibles","localData","foundInner","writes","Array","isArray","_multiWriteArray","_multiWriteHash","writeArray","w","writeHash","from","Catbus","_batchQueue","_primed","window","requestAnimationFrame","flush","nextTick","createChild","cycles","q"],"mappings":"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"}