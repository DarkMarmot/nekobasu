{"version":3,"file":"catbus.umd.min.js","sources":["../src/flib.js","../src/dataTypes.js","../src/bus.js","../src/nyan.js","../src/nyanBus.js","../src/scope.js","../src/packet.js","../src/subscriberList.js","../src/data.js","../src/poolAspects.js","../src/frame.js","../src/pool.js","../src/stream.js","../src/catbus.js"],"sourcesContent":["\nimport Catbus from './catbus.js';\n\nfunction ALWAYS_TRUE(){\n    return true;\n}\n\nfunction ALWAYS_FALSE(){\n    return false;\n}\n\n\nfunction TO_SOURCE(msg, source) {\n    return source;\n}\n\nfunction TO_TOPIC(msg, source, topic) {\n    return topic;\n}\n\nfunction TO_MSG(msg) {\n    return msg;\n}\n\nfunction NOOP(){\n\n}\n\n\nfunction FUNCTOR(val) {\n    return (typeof val === 'function') ? val : function() { return val; };\n}\n\nconst Func = {\n\n\n    ASSERT_NEED_ONE_ARGUMENT: function(args){\n        if(args.length < 1)\n            throw new Error('Method requires at least one argument.');\n    },\n\n    ASSERT_IS_FUNCTION: function(func){\n        if(typeof func !== 'function')\n            throw new Error('Argument [func] is not of type function.');\n    },\n\n    getAlwaysTrue: function(){\n       return function(){ return true;}\n    },\n\n    getBatchTimer: function(){\n        const pool = this;\n        return function() {\n            Catbus.enqueue(pool);\n        }\n    },\n\n    getSyncTimer: function(){\n        const pool = this;\n        return function() {\n            pool.release(pool);\n        }\n    },\n\n    getDeferTimer: function(){\n        const pool = this;\n        return function() {\n            setTimeout(pool.release, 0, pool);\n        }\n    },\n\n    getThrottleTimer: function(fNum){\n\n        const pool = this;\n        fNum = FUNCTOR(fNum);\n        let wasEmpty = false;\n        let timeoutId = null;\n        let msgDuringTimer = false;\n        const auto = pool.keep.auto;\n\n        function timedRelease(fromTimeout){\n\n            if(pool.stream.dead)\n                return;\n\n            const nowEmpty = pool.keep.isEmpty;\n\n            if(!fromTimeout){\n                if(!timeoutId) {\n                    pool.release(pool);\n                    wasEmpty = false;\n                    timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n                } else {\n                    msgDuringTimer = true;\n                }\n                return;\n            }\n\n            if(nowEmpty){\n                if(wasEmpty){\n                    // throttle becomes inactive\n                } else {\n                    // try one more time period to maintain throttle\n                    wasEmpty = true;\n                    msgDuringTimer = false;\n                    timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n                }\n            } else {\n                pool.release(pool);\n                wasEmpty = false;\n                timeoutId = setTimeout(timedRelease, fNum.call(pool), true);\n            }\n\n        }\n\n        return timedRelease;\n\n    },\n\n    getQueue: function(n){\n\n        n = n || Infinity;\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            if(buffer.length < n)\n                buffer.push(msg);\n            return buffer;\n        };\n\n        f.isBuffer = ALWAYS_TRUE;\n\n        f.next = function(){\n            return buffer.shift();\n        };\n\n        f.isEmpty = function(){\n            return buffer.length === 0;\n        };\n\n        f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getScan: function(func, seed){\n\n        const hasSeed = arguments.length === 2;\n        let acc;\n        let initMsg = true;\n\n        const f = function(msg, source){\n\n            if(initMsg){\n                initMsg = false;\n                if(hasSeed){\n                    acc = func(seed, msg, source);\n                } else {\n                    acc = msg;\n                }\n            } else {\n                acc = func(acc, msg, source);\n            }\n\n            return acc;\n\n        };\n\n        f.reset = NOOP;\n\n        f.next = f.content = function(){\n            return acc;\n        };\n\n\n        return f;\n    },\n\n    getGroup: function(groupBy){\n\n        groupBy = groupBy || TO_SOURCE;\n        const hash = {};\n\n        const f = function(msg, source){\n\n            const g = groupBy(msg, source);\n            hash[g] = msg;\n            return hash;\n\n        };\n\n        f.reset = function(){\n            for(const k in hash){\n                delete hash[k];\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return hash;\n        };\n\n        return f;\n\n    },\n\n    getKeepLast: function(n){\n\n        if(!n || n < 0) {\n\n            let last;\n\n            const f = function(msg, source){\n                return last = msg;\n            };\n\n            f.reset = function(){\n                f.isEmpty = true;\n            };\n\n            f.next = f.content = function(){\n                return last;\n            };\n\n            return f;\n\n        }\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            buffer.push(msg);\n            if(buffer.length > n)\n                buffer.shift();\n            return buffer;\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n\n\n    getKeepFirst: function(n){\n\n        if(!n || n < 0) {\n\n            let firstMsg;\n            let hasFirst = false;\n            const f = function (msg, source) {\n                return hasFirst ? firstMsg : firstMsg = msg;\n            };\n\n            f.reset = function(){\n                firstMsg = false;\n                f.isEmpty = true;\n            };\n\n            f.next = f.content = function(){\n                return firstMsg;\n            };\n\n            return f;\n        }\n\n        const buffer = [];\n\n        const f = function(msg, source){\n\n            if(buffer.length < n)\n                buffer.push(msg);\n            return buffer;\n\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getKeepAll: function(){\n\n        const buffer = [];\n\n        const f = function(msg, source){\n            buffer.push(msg);\n            return buffer;\n        };\n\n        f.reset = function(){\n            while(buffer.length) {\n                buffer.shift();\n            }\n            f.isEmpty = true;\n        };\n\n        f.next = f.content = function(){\n            return buffer;\n        };\n\n        return f;\n\n    },\n\n    getWhenCount: function(n) {\n\n        let latched = false;\n\n        const f = function(messages){\n            latched = latched || messages.length >= n;\n            return latched;\n        };\n\n        f.reset = function(){\n            latched = false;\n        };\n\n        return f;\n\n    },\n\n    getWhenKeys: function(keys) {\n\n        const keyHash = {};\n        const len = keys.length;\n\n        for(let i = 0; i < len; i++){\n            const k = keys[i];\n            keyHash[k] = true;\n        }\n\n        let latched = false;\n\n        const f = function (messagesByKey) {\n\n            if(latched)\n                return true;\n\n            for (let i = 0; i < len; i++) {\n                const k = keys[i];\n                if (!messagesByKey.hasOwnProperty(k))\n                    return false;\n            }\n\n            return latched = true;\n\n        };\n\n        f.reset = function(){\n            latched = false;\n            for(const k in keyHash){\n                delete keyHash[k];\n            }\n        };\n\n        return f;\n\n    },\n\n    getSkipDupes: function() {\n\n        let hadMsg = false;\n        let lastMsg;\n\n        return function (msg) {\n\n            const diff = !hadMsg || msg !== lastMsg;\n            lastMsg = msg;\n            hadMsg = true;\n            return diff;\n\n        }\n\n    },\n\n\n    ASSERT_NOT_HOLDING: function(bus){\n        if(bus.holding)\n            throw new Error('Method cannot be invoked while holding messages in the frame.');\n    },\n\n    ASSERT_IS_HOLDING: function(bus){\n        if(!bus.holding)\n            throw new Error('Method cannot be invoked unless holding messages in the frame.');\n    }\n\n};\n\nFunc.TO_SOURCE = TO_SOURCE;\nFunc.TO_TOPIC = TO_TOPIC;\nFunc.To_MSG = TO_MSG;\nFunc.FUNCTOR = FUNCTOR;\nFunc.ALWAYS_TRUE = ALWAYS_TRUE;\nFunc.ALWAYS_FALSE = ALWAYS_FALSE;\nFunc.NOOP = NOOP;\n\nexport default Func;","\n\nconst DATA_TYPES = {\n\n    ACTION:   'action',\n    MIRROR:   'mirror',\n    STATE:    'state',\n    COMPUTED: 'computed',\n    NONE:     'none',\n    ANY:      'any'\n\n};\n\nconst reverseLookup = {};\n\nfor(const p in DATA_TYPES){\n    const v = DATA_TYPES[p];\n    reverseLookup[v] = p;\n}\n\nfunction isValid(type){\n    return reverseLookup.hasOwnProperty(type);\n}\n\n\nexport { DATA_TYPES, isValid};\n\n","\nimport Frame from './frame.js';\nimport F from './flib.js';\nimport Stream from './stream.js';\n\n\nclass Bus {\n\n    constructor(scope, streams) {\n\n        this._frames = [];\n        this._dead = false;\n        this._scope = scope; // data scope\n        this._children = []; // from forks\n        this._parent = null;\n\n        if(scope)\n            scope._busList.push(this);\n\n        const f = new Frame(this, streams || []);\n        this._frames.push(f);\n        this._currentFrame = f;\n\n    };\n\n    get children(){\n\n        return this._children.map((d) => d);\n\n    };\n\n    get parent() { return this._parent; };\n\n    set parent(newParent){\n\n        const oldParent = this.parent;\n\n        if(oldParent === newParent)\n            return;\n\n        if(oldParent) {\n            const i = oldParent._children.indexOf(this);\n            oldParent._children.splice(i, 1);\n        }\n\n        this._parent = newParent;\n\n        if(newParent) {\n            newParent._children.push(this);\n        }\n\n        return this;\n\n    };\n\n    get dead() {\n        return this._dead;\n    };\n\n    get holding() {\n        return this._currentFrame._holding;\n    };\n\n    get scope() {\n        return this._scope;\n    }\n\n    // NOTE: unlike most bus methods, this one returns a new current frame (not the bus!)\n\n    addFrame(streams) {\n\n        const lastFrame = this._currentFrame;\n        const nextFrame = this._currentFrame = new Frame(this, streams);\n        this._frames.push(nextFrame);\n\n        _wireFrames(lastFrame, nextFrame);\n\n        return nextFrame;\n    };\n\n\n    // create stream\n    spawn(){\n\n    }\n\n    // convert each stream into a bus, wiring prior streams, dump in array\n\n    split(){\n\n        F.ASSERT_NOT_HOLDING(this);\n\n    };\n\n    fork() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        const fork = new Bus(this.scope);\n        fork.parent = this;\n        _wireFrames(this._currentFrame, fork._currentFrame);\n\n        return fork;\n    };\n\n    back() {\n\n        if(!this._parent)\n            throw new Error('Cannot exit fork, parent does not exist!');\n\n        return this.parent;\n\n    };\n\n    add(bus) {\n\n        const frame = this.addFrame(); // wire from current bus\n        _wireFrames(bus._currentFrame, frame); // wire from outside bus\n        return this;\n\n    };\n\n    defer() {\n        return this.timer(F.getDeferTimer);\n    };\n\n    batch() {\n        return this.timer(F.getBatchTimer);\n    };\n\n    sync() {\n        return this.timer(F.getSyncTimer);\n    };\n\n    throttle(fNum) {\n        return this.timer(F.getThrottleTimer, fNum);\n    };\n\n    hold() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().hold();\n        return this;\n\n    };\n\n    poll() {\n\n        const frame1 = this._frames[0];\n\n        if(frame1._streams.length > 0){\n            frame1.poll();\n            return this;\n        }\n\n        if(this._frames.length !== 1){\n            const frame2 = this._frames[1];\n            frame2.poll();\n        }\n\n        return this;\n\n    };\n\n    event(name, target, eventName, useCapture) {\n\n        eventName = eventName || name;\n        F.ASSERT_NOT_HOLDING(this);\n        const stream = Stream.fromEvent(target, eventName, useCapture);\n        stream.name = name;\n        this.addFrame([stream]);\n        return this;\n\n    };\n\n    eventList(list) {\n\n        F.ASSERT_NOT_HOLDING(this);\n\n        const len = list.length;\n        const streams = [];\n\n        for(let i = 0; i < len; i++){\n            const e = list[i];\n            const eventName = e.eventName || e.name;\n            const name = e.name || e.eventName;\n            const s = Stream.fromEvent(e.target, eventName, e.useCapture);\n            s.name = name;\n            streams.push(s);\n        }\n\n        this.addFrame(streams);\n        return this;\n\n    };\n\n    scan(func, seed){\n        return this.reduce(F.getScan, func, seed);\n    };\n\n    delay(num) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().delay(num);\n        return this;\n\n    };\n\n    willReset(){\n\n        F.ASSERT_IS_HOLDING(this);\n        return this.clear(F.getAlwaysTrue);\n\n    }\n\n    whenKeys(keys) {\n        return this.when(F.getWhenKeys, keys);\n    };\n\n    group(by) {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().hold().reduce(F.getGroup, by);\n        return this;\n    };\n\n    groupByTopic() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().hold().reduce(F.getGroup, F.TO_TOPIC);\n        return this;\n    };\n\n    all() {\n        return this.reduce(F.getKeepAll);\n    };\n\n    first(n) {\n        return this.reduce(F.getKeepFirst, n);\n    };\n\n    last(n) {\n        return this.reduce(F.getKeepLast, n);\n    };\n\n    clear(factory, ...args) {\n        return this._currentFrame.clear(factory, ...args);\n    };\n\n    reduce(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.reduce(factory, ...args) :\n            this.addFrame().hold().reduce(factory, ...args).timer(F.getSyncTimer);\n        return this;\n\n    };\n\n    timer(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.timer(factory, ...args) :\n            this.addFrame().hold().timer(factory, ...args);\n        return this;\n\n    };\n\n    until(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.until(factory, ...args) :\n            this.addFrame().hold().until(factory, ...args).timer(F.getSyncTimer);\n        return this;\n\n    };\n\n    when(factory, ...args) {\n\n        this.holding ?\n            this._currentFrame.when(factory, ...args) :\n            this.addFrame().hold().when(factory, ...args).timer(F.getSyncTimer);\n        return this;\n\n    };\n\n    run(func) {\n\n        F.ASSERT_IS_FUNCTION(func);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().run(func);\n        return this;\n\n    };\n\n    merge() {\n\n        F.ASSERT_NOT_HOLDING(this);\n\n        const mergedStream = new Stream();\n\n        const lastFrame = this._currentFrame;\n        const nextFrame = this._currentFrame = new Frame(this, [mergedStream]);\n        this._frames.push(nextFrame);\n\n        const streams = lastFrame._streams;\n        const len = streams.length;\n        for (let i = 0; i < len; i++) {\n            const s = streams[i];\n            s.addTarget(mergedStream);\n        }\n\n        return this;\n    };\n\n    msg(fAny) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().msg(fAny);\n        return this;\n\n    };\n\n    transform(fAny) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().transform(fAny);\n        return this;\n\n    };\n\n    source(fStr) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().source(fStr);\n        return this;\n\n    };\n\n    filter(func) {\n\n        F.ASSERT_NEED_ONE_ARGUMENT(arguments);\n        F.ASSERT_IS_FUNCTION(func);\n        F.ASSERT_NOT_HOLDING(this);\n\n        this.addFrame().filter(func);\n        return this;\n\n    };\n\n    skipDupes() {\n\n        F.ASSERT_NOT_HOLDING(this);\n        this.addFrame().skipDupes();\n        return this;\n\n    };\n\n    toStream() {\n        // merge, fork -> immutable stream?\n    };\n\n    destroy() {\n\n        if (this.dead)\n            return this;\n\n        this._dead = true;\n\n        const frames = this._frames;\n\n        for (const f of frames) {\n            f.destroy();\n        }\n\n        return this;\n\n    };\n\n}\n\n// send messages from streams in one frame to new empty streams in another frame\n// injects new streams to frame 2\n\nfunction _wireFrames(frame1, frame2) {\n\n    const streams1 = frame1._streams;\n    const streams2 = frame2._streams;\n\n    const len = streams1.length;\n\n    for (let i = 0; i < len; i++) {\n\n        const s1 = streams1[i];\n        const s2 = new Stream(frame2);\n        s2.name = s1.name;\n        streams2.push(s2);\n        s1.addTarget(s2);\n\n    }\n\n}\n\n\nexport default Bus;\n","\n\nconst Nyan = {};\n\n// then = applies to all words in a phrase\n// watch: ^ = action, need, event, watch | read, must\n// then:  run, read, attr, and, style, write, blast, filter\n\nconst operationDefs = [\n\n    {name: 'ACTION', sym: '^',  react: true, subscribe: true, need: true, solo: true},\n    {name: 'WIRE',   sym: '~',  react: true, follow: true}, // INTERCEPT\n    {name: 'WATCH',  sym: null, react: true, follow: true},\n    {name: 'EVENT',  sym: '@',  react: true, event: true},\n    {name: 'READ',   sym: null, then: true, read: true},\n    {name: 'ATTR',   sym: '#',  then: true, solo: true, output: true},\n    {name: 'AND',    sym: '&',  then: true },\n    {name: 'STYLE',  sym: '$',  then: true,  solo: true, output: true },\n    {name: 'WRITE',  sym: '=',  then: true,  solo: true },\n    {name: 'RUN',    sym: '*',  then: true, output: true },\n    {name: 'FILTER', sym: '%',  then: true }\n\n];\n// cat, dog | & meow, kitten {*log} | =puppy\n\n\n// todo make ! a trailing thingie, must goes away\n// trailing defs -- ! = needs message in data to continue, ? = data must exist or throw error\n// {name: 'BEGIN',  sym: '{'}, -- fork\n// {name: 'END',    sym: '}'}, -- back\n// {name: 'PIPE',   sym: '|'}, -- phrase delimiter\n// read = SPACE\n// - is data maybe (data point might not be present)\n// ? is object maybe (object might not be there)\n\nconst operationsBySymbol = {};\nconst operationsByName = {};\nconst symbolsByName = {};\nconst namesBySymbol = {};\nconst reactionsByName = {};\nconst withReactionsByName = {};\nconst thenByName = {};\n\nfor(let i = 0; i < operationDefs.length; i++){\n\n    const op = operationDefs[i];\n    const name = op.name;\n    const sym = op.sym;\n\n    if(sym) {\n        operationsBySymbol[sym] = op;\n        namesBySymbol[sym] = name;\n    }\n\n    operationsByName[name] = op;\n    symbolsByName[name] = sym;\n\n    if(op.then){\n        thenByName[name] = true;\n    }\n\n    if(op.react) {\n        reactionsByName[name] = true;\n        withReactionsByName[name] = true;\n    }\n\n}\n\n\n\nclass NyanWord {\n\n    constructor(name, operation, maybe, need, topic, alias, monitor, extracts){\n\n        this.name = name;\n        this.operation = operation;\n        this.maybe = maybe || false;\n        this.need = need || false;\n        this.topic = topic || null;\n        this.alias = alias || null;\n        this.monitor = monitor || false;\n        this.extracts = extracts || null; // possible list of message property pulls\n        // this.useCapture =\n\n    }\n\n}\n\n\nfunction parse(str, isProcess) {\n\n    const sentences = [];\n\n    // split on parentheses and remove empty chunks (todo optimize for speed)\n    let chunks = str.split(/([{}])/).map(d => d.trim()).filter(d => d);\n\n    for(let i = 0; i < chunks.length; i++){\n\n        const chunk = chunks[i];\n        const sentence = (chunk === '}' || chunk === '{') ? chunk : parseSentence(chunk);\n\n        if(typeof sentence === 'string' || sentence.length > 0)\n            sentences.push(sentence);\n\n    }\n\n    return validate(sentences, isProcess);\n\n\n}\n\nfunction validate(sentences, isProcess){\n\n    const cmdList = [];\n    let firstPhrase = true;\n    \n    for(let i = 0; i < sentences.length; i++){\n        const s = sentences[i];\n        if(typeof s !== 'string') {\n            for (let j = 0; j < s.length; j++) {\n                const phrase = s[j];\n                if(firstPhrase && !isProcess) {\n                    validateReactPhrase(phrase);\n                    firstPhrase = false;\n                    cmdList.push({name: 'REACT', phrase: phrase});\n                }\n                else {\n                    validateProcessPhrase(phrase);\n                    cmdList.push({name: 'PROCESS', phrase: phrase});\n                }\n            }\n        } else if (s === '{') {\n            cmdList.push({name: 'FORK'});\n        } else if (s === '}') {\n            cmdList.push({name: 'BACK'});\n        }\n    }\n\n    return cmdList;\n}\n\n\nfunction validateReactPhrase(phrase){\n\n    let hasReaction = false;\n    for(let i = 0; i < phrase.length; i++){\n\n        const nw = phrase[i];\n        const operation = nw.operation = nw.operation || 'WATCH';\n        hasReaction = hasReaction || reactionsByName[operation];\n        if(!withReactionsByName[operation])\n            throw new Error('This Nyan command cannot be in a reaction!');\n\n    }\n\n    if(!hasReaction)\n        throw new Error('Nyan commands must begin with an observation!');\n\n}\n\n\n\nfunction validateProcessPhrase(phrase){\n\n    const firstPhrase = phrase[0];\n    const firstOperation = firstPhrase.operation || 'READ';\n\n    if(!thenByName[firstOperation])\n        throw new Error('Illegal operation in phrase!'); // unknown or reactive\n\n    for(let i = 0; i < phrase.length; i++){\n\n        const nw = phrase[i];\n        nw.operation = nw.operation || firstOperation;\n        if(nw.operation !== firstOperation){\n            console.log('mult', nw.operation, firstOperation);\n            throw new Error('Multiple operation types in phrase (only one allowed)!');\n        }\n\n    }\n\n}\n\n\n\nfunction parseSentence(str) {\n\n    const result = [];\n    const chunks = str.split('|').map(d => d.trim()).filter(d => d);\n\n    for(let i = 0; i < chunks.length; i++){\n\n        const chunk = chunks[i];\n        const phrase = parsePhrase(chunk);\n        result.push(phrase);\n\n    }\n\n    return result;\n\n}\n\nfunction parsePhrase(str) {\n\n    const words = [];\n    const rawWords = str.split(',').map(d => d.trim()).filter(d => d);\n\n    const len = rawWords.length;\n\n    for (let i = 0; i < len; i++) {\n\n        const rawWord = rawWords[i];\n        console.log('word=', rawWord);\n        const chunks = rawWord.split(/([(?!:.)])/).map(d => d.trim()).filter(d => d);\n        console.log('to:', chunks);\n        const nameAndOperation = chunks.shift();\n        const firstChar = rawWord[0];\n        const operation = namesBySymbol[firstChar];\n        const start = operation ? 1 : 0;\n        const name = nameAndOperation.slice(start);\n        const extracts = [];\n\n        let maybe = false;\n        let monitor = false;\n        let topic = null;\n        let alias = null;\n        let need = false;\n\n        while(chunks.length){\n\n            const c = chunks.shift();\n\n            switch(c){\n\n                case '.':\n\n                    const prop = chunks.length && chunks[0]; // todo assert not operation\n                    const silentFail = chunks.length > 1 && (chunks[1] === '?');\n\n                    if(prop) {\n                        extracts.push({name: prop, silentFail: silentFail});\n                        chunks.shift(); // remove word from queue\n                        if(silentFail)\n                            chunks.shift(); // remove ? from queue\n                    }\n\n                    break;\n\n                case '?':\n                    maybe = true;\n                    break;\n\n                case '!':\n                    need = true;\n                    break;\n\n                case ':':\n\n                    if(chunks.length){\n                        const next = chunks[0];\n                        if(next === '('){\n                            monitor = true;\n                        } else {\n                            topic = next;\n                            chunks.shift(); // remove topic from queue\n                        }\n                    } else {\n                        monitor = true;\n                    }\n\n                    break;\n\n                case '(':\n\n                    if(chunks.length){\n                        alias = chunks.shift(); // todo assert not operation\n                    }\n\n                    break;\n\n            }\n\n        }\n\n        alias = alias || topic || name;\n        const nw = new NyanWord(name, operation, maybe, need, topic, alias, monitor, extracts);\n        words.push(nw);\n\n    }\n\n    return words;\n\n}\n\nNyan.parse = parse;\n\n\nexport default Nyan;\n\n","import Stream from './stream.js';\nimport Nyan from './nyan.js';\n\n\nfunction getPacketFromDataWord(scope, word){\n\n    const data = scope.find(word.name, !word.maybe);\n    const peek = data && data.peek(word.topic);\n    return peek;\n\n}\n\n\nfunction getSurveyFromDataWord(scope, word){\n\n    const data = scope.find(word.name, !word.maybe);\n    return data && data.survey();\n\n}\n\n\nfunction getDoSkipNamedDupes(names){\n\n    let lastMsg = {};\n    const len = names.length;\n\n    return function doSkipNamedDupes(msg) {\n\n        let diff = false;\n        for(let i = 0; i < len; i++){\n            const name = names[i];\n            if(!lastMsg.hasOwnProperty(name) || lastMsg[name] !== msg[name])\n                diff = true;\n            lastMsg[name] = msg[name];\n        }\n\n        return diff;\n\n    };\n}\n\n\nfunction getDoRead(scope, phrase){\n\n    const len = phrase.length;\n    const firstWord = phrase[0];\n\n    if(len > 1 || firstWord.monitor) { // if only reading word is a wildcard subscription then hash as well\n        return getDoReadMultiple(scope, phrase);\n    } else {\n        return getDoReadSingle(scope, firstWord);\n    }\n\n}\n\n\nfunction getDoAnd(scope, phrase) {\n\n    return getDoReadMultiple(scope, phrase, true);\n\n}\n\n\nfunction getDoReadSingle(scope, word) {\n\n    return function doReadSingle() {\n\n        const packet = getPacketFromDataWord(scope, word);\n        return packet && packet.msg;\n\n    };\n\n}\n\n\nfunction getDoReadMultiple(scope, phrase, isAndOperation){\n\n\n        const len = phrase.length;\n\n        return function doReadMultiple(msg) {\n\n            msg = (isAndOperation && msg) || {};\n\n            for (let i = 0; i < len; i++) {\n                const word = phrase[i];\n\n                if(word.monitor){\n\n                    const survey = getSurveyFromDataWord(scope, word);\n                    for(const [key, value] of survey){\n                        msg[key] = value;\n                    }\n\n                } else {\n\n                    const packet = getPacketFromDataWord(scope, word);\n                    const prop = word.monitor ? (word.alias || word.topic) : (word.alias || word.name);\n                    if (packet)\n                        msg[prop] = packet.msg;\n\n                }\n\n            }\n\n            return msg;\n\n        };\n\n}\n\n\n// get data stream -- store data in bus, emit into stream on poll()\n\n\nfunction getDataStream(scope, word, canPoll) {\n\n    const data = scope.find(word.name, !word.maybe);\n    if(word.monitor){\n        return Stream.fromMonitor(data, word.alias, canPoll);\n    } else {\n        return Stream.fromSubscribe(data, word.topic, word.alias, canPoll);\n    }\n\n}\n\n\nfunction getEventStream(scope, word, node){\n\n    return Stream.fromEvent(node, word.topic, word.useCapture, word.alias);\n\n}\n\nfunction getNeedsArray(phrase){\n    return phrase.filter(word => word.operation.need).map(word => word.alias);\n}\n\n\nfunction applyReaction(scope, bus, phrase, target) { // target is some event emitter\n\n    const need = [];\n    const skipDupes = [];\n    const streams = [];\n    const extracts = [];\n\n    if(phrase.length === 1 && phrase[0].operation === 'ACTION'){\n        bus.addFrame(getDataStream(scope, phrase[0], false));\n        return;\n    }\n\n    for(let i = 0; i < phrase.length; i++){\n\n        const word = phrase[i];\n        const operation = word.operation;\n\n        if(operation === 'WATCH') {\n            streams.push(getDataStream(scope, word, true));\n            skipDupes.push(word.alias)\n        }\n        else if(operation === 'WIRE'){\n            streams.push(getDataStream(scope, word, true));\n        }\n        else if(operation === 'EVENT') {\n            streams.push(getEventStream(scope, word));\n        }\n\n        if(word.extracts)\n            extracts.push(word);\n\n        if(word.need)\n            need.push(word.alias);\n\n    }\n\n    bus.addFrame(streams);\n\n    if(streams.length > 1) {\n\n        bus.merge().group().batch();\n\n        if(need.length)\n            bus.whenKeys(need); // todo is alias here?\n\n        if(skipDupes.length){\n            bus.filter(getDoSkipNamedDupes(skipDupes));\n        }\n\n    } else if(skipDupes.length) {\n\n        bus.skipDupes();\n\n    }\n\n}\n\nfunction applyProcess(scope, bus, phrase, context, node) {\n\n    const operation = phrase[0].operation; // same for all words in a process phrase\n\n    if(operation === 'READ') {\n        bus.msg(getDoRead(scope, phrase));\n        const needs = getNeedsArray(phrase);\n        if(needs.length)\n            bus.whenKeys(needs);\n    } else if (operation === 'AND') {\n        bus.msg(getDoAnd(scope, phrase));\n        const needs = getNeedsArray(phrase);\n        if(needs.length)\n            bus.whenKeys(needs);\n    } else if (operation === 'FILTER') {\n        applyFilterProcess(bus, phrase, context);\n    } else if (operation === 'RUN') {\n        applyRunProcess(bus, phrase, context);\n    } else if (operation === 'WRITE') {\n\n    } else if (operation === 'SPRAY') {\n        // alias to target data points of different names, i.e. < cat(dog), meow(bunny)\n    }\n\n}\n\n\nfunction applyRunProcess(bus, phrase, context){\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++) {\n\n        const word = phrase[i];\n        const name = word.name;\n        const method = context[name];\n\n        const f = function (msg, source, topic) {\n            return method.call(context, msg, source, topic);\n        };\n\n        bus.run(f);\n\n    }\n\n}\n\n\nfunction applyFilterProcess(bus, phrase, context){\n\n    const len = phrase.length;\n\n    for(let i = 0; i < len; i++) {\n\n        const word = phrase[i];\n        const name = word.name;\n        const method = context[name];\n\n        const f = function (msg, source, topic) {\n            return method.call(context, msg, source, topic);\n        };\n\n        bus.filter(f);\n\n    }\n\n}\n\n\nfunction nyanToBus(scope, bus, str, context, target){\n\n    const nyan = Nyan.parse(str);\n    const len = nyan.length;\n\n    for(let i = 0; i < len; i++){\n\n        const cmd = nyan[i];\n        const name = cmd.name;\n        const phrase = cmd.phrase;\n\n        if(name === 'FORK'){\n            bus = bus.fork();\n        } else if (name === 'BACK'){\n            bus = bus.back();\n        } else {\n\n            if(name === 'PROCESS')\n                applyProcess(scope, bus, phrase, context, target);\n            else // name === 'REACT'\n                applyReaction(scope, bus, phrase, target);\n\n        }\n    }\n\n    return bus;\n\n}\n\nexport default nyanToBus;","\nimport F from './flib.js';\nimport Data from './data.js';\nimport { DATA_TYPES, isValid } from './dataTypes.js';\nimport Bus from './bus.js';\nimport Nyan from './nyan.js';\nimport Stream from './stream.js';\nimport nyanToBus from './nyanBus.js';\n\nlet idCounter = 0;\n\nfunction _destroyEach(arr){\n\n    const len = arr.length;\n    for(let i = 0; i < len; i++){\n        const item = arr[i];\n        item.destroy();\n    }\n\n}\n\n\nclass Scope{\n\n    constructor(name) {\n\n        this._id = ++idCounter;\n        this._name = name;\n        this._parent = null;\n        this._children = [];\n        this._busList = [];\n        this._dataList = new Map();\n        this._valves = new Map();\n        this._mirrors = new Map();\n        this._dead = false;\n\n    };\n\n    get name() { return this._name; };\n    get dead() { return this._dead; };\n\n    get children(){\n\n        return this._children.map((d) => d);\n\n    };\n\n\n    react(str, context, node){ // string is Nyan\n\n        if(!str)\n            throw new Error('Need a Nyan phrase!');\n\n        let b = new Bus(this);\n\n        return nyanToBus(this, b, str, context, node);\n\n    };\n\n    clear(){\n\n        if(this._dead)\n            return;\n\n        _destroyEach(this.children); // iterates over copy to avoid losing position as children leaves their parent\n        _destroyEach(this._busList);\n        _destroyEach(this._dataList.values());\n\n        this._children = [];\n        this._busList = [];\n        this._dataList.clear();\n        this._valves.clear();\n        this._mirrors.clear();\n\n    };\n\n    destroy(){\n\n        this.clear();\n        this.parent = null;\n        this._dead = true;\n\n    };\n\n    createChild(name){\n\n        let child = new Scope(name);\n        child.parent = this;\n        return child;\n\n    };\n\n    insertParent(newParent){\n\n        newParent.parent = this.parent;\n        this.parent = newParent;\n        return this;\n\n    };\n\n    get parent() { return this._parent; };\n\n    set parent(newParent){\n\n        const oldParent = this.parent;\n\n        if(oldParent === newParent)\n            return;\n\n        if(oldParent) {\n            const i = oldParent._children.indexOf(this);\n            oldParent._children.splice(i, 1);\n        }\n\n        this._parent = newParent;\n\n        if(newParent) {\n            newParent._children.push(this);\n        }\n\n        return this;\n\n    };\n\n    set valves(list){\n\n        for(const name of list){\n            this._valves.set(name, true);\n        }\n\n    }\n\n    get valves(){ return Array.from(this._valves.keys());};\n\n\n    _createMirror(data){\n\n        const mirror = Object.create(data);\n        mirror._type = DATA_TYPES.MIRROR;\n        this._mirrors.set(data.name, mirror);\n        return mirror;\n\n    };\n\n    _createData(name, type){\n\n        const d = new Data(this, name, type);\n        this._dataList.set(name, d);\n        return d;\n\n    };\n\n\n    data(name){\n\n        return this.grab(name) || this._createData(name, DATA_TYPES.NONE);\n\n    };\n\n\n    action(name){\n\n        const d = this.grab(name);\n\n        if(d)\n            return d.verify(DATA_TYPES.ACTION);\n\n        return this._createData(name, DATA_TYPES.ACTION);\n\n    };\n\n\n    state(name){\n\n        const d = this.grab(name);\n\n        if(d)\n            return d.verify(DATA_TYPES.STATE);\n\n        const state = this._createData(name, DATA_TYPES.STATE);\n        this._createMirror(state);\n        return state;\n\n    };\n\n\n    findDataSet(names, required){\n\n\n        const result = {};\n        for(const name of names){\n            result[name] = this.find(name, required);\n        }\n\n        return result;\n\n    };\n\n    readDataSet(names, required){\n\n        const dataSet = this.findDataSet(names, required);\n        const result = {};\n\n        for(const d of dataSet) {\n            if (d) {\n                const lastPacket = d.peek();\n                if (lastPacket)\n                    result[d.name] = lastPacket.msg;\n            }\n        }\n\n        return result;\n    };\n\n\n    // created a flattened view of all data at and above this scope\n\n    flatten(){\n\n        let scope = this;\n\n        const result = new Map();\n        const appliedValves = new Map();\n\n        for(const [key, value] of scope._dataList){\n            result.set(key, value);\n        }\n\n        while(scope = scope._parent){\n\n            const dataList = scope._dataList;\n            const valves = scope._valves;\n            const mirrors = scope._mirrors;\n\n            if(!dataList.size)\n                continue;\n\n            // further restrict valves with each new scope\n\n            if(valves.size){\n                if(appliedValves.size) {\n                    for (const key of appliedValves.keys()) {\n                        if(!valves.has(key))\n                            appliedValves.delete(key);\n                    }\n                } else {\n                    for (const [key, value] of valves.entries()) {\n                        appliedValves.set(key, value);\n                    }\n                }\n            }\n\n            const possibles = appliedValves.size ? appliedValves : dataList;\n\n            for(const key of possibles.keys()) {\n                if (!result.has(key)) {\n\n                    const data = mirrors.get(key) || dataList.get(key);\n                    if (data)\n                        result.set(key, data);\n                }\n            }\n\n        }\n\n        return result;\n\n    };\n\n\n    find(name, required){\n\n        const localData = this.grab(name);\n        if(localData)\n            return localData;\n\n        let scope = this;\n\n        while(scope = scope._parent){\n\n            const valves = scope._valves;\n\n            // if valves exist and the name is not present, stop looking\n            if(valves.size && !valves.has(name)){\n                break;\n            }\n\n            const mirror = scope._mirrors.get(name);\n\n            if(mirror)\n                return mirror;\n\n            const d = scope.grab(name);\n\n            if(d)\n                return d;\n\n        }\n\n        if(required)\n            throw new Error('Required data: ' + name + ' not found!');\n\n        return null;\n\n    };\n\n    findOuter(name, required){\n\n        let foundInner = false;\n        const localData = this.grab(name);\n        if(localData)\n            foundInner = true;\n\n        let scope = this;\n\n        while(scope = scope._parent){\n\n            const valves = scope._valves;\n\n            // if valves exist and the name is not present, stop looking\n            if(valves.size && !valves.has(name)){\n                break;\n            }\n\n            const mirror = scope._mirrors.get(name);\n\n            if(mirror) {\n\n                if(foundInner)\n                    return mirror;\n\n                foundInner = true;\n                continue;\n            }\n\n            const d = scope.grab(name);\n\n            if(d) {\n\n                if(foundInner)\n                    return d;\n\n                foundInner = true;\n            }\n\n        }\n\n        if(required)\n            throw new Error('Required data: ' + name + ' not found!');\n\n        return null;\n\n    };\n\n    grab(name, required) {\n\n        const data = this._dataList.get(name);\n\n        if(!data && required)\n            throw new Error('Required Data: ' + name + ' not found!');\n\n        return data || null;\n\n    };\n\n    transaction(writes){\n\n        if(Array.isArray(writes))\n            return this._multiWriteArray(writes);\n        else if(typeof writes === 'object')\n            return this._multiWriteHash(writes);\n\n        throw new Error('Write values must be in an array of object hash.');\n\n    };\n\n    // write {name, topic, value} objects as a transaction\n    _multiWriteArray(writeArray, dimension){\n\n        const list = [];\n\n        for(const w of writeArray){\n            const d = this.find(w.name);\n            d.silentWrite(w.value, w.topic);\n            list.push(d);\n        }\n\n        let i = 0;\n        for(const d of list){\n            const w = writeArray[i];\n            d.refresh(w.topic);\n        }\n\n        return this;\n\n    };\n\n\n    // write key-values as a transaction\n    _multiWriteHash(writeHash){\n\n        const list = [];\n\n        for(const k in writeHash){\n            const v = writeHash[k];\n            const d = this.find(k);\n            d.silentWrite(v);\n            list.push(d);\n        }\n\n        for(const d of list){\n            d.refresh();\n        }\n\n        return this;\n\n    };\n\n}\n\nexport default Scope;\n","\nclass Packet {\n\n    constructor(msg, topic, source) {\n        this._msg       = msg;\n        this._topic     = topic;\n        this._source    = source;\n        this._timestamp = Date.now();\n    };\n\n    get msg() { return this._msg; };\n    get topic() { return this._topic; };\n    get source() { return this._source; };\n    get timestamp() { return this._timestamp; };\n\n}\n\nexport default Packet;","\nimport Packet from './packet.js';\nimport { DATA_TYPES } from './dataTypes';\n\nclass SubscriberList {\n\n    constructor(topic, data) {\n\n        this._topic = topic;\n        this._subscribers = [];\n        this._lastPacket = null;\n        this._data = data;\n        this._name = data._name;\n        this._dead = false;\n\n    };\n\n    get lastPacket() { return this._lastPacket; };\n    get data() { return this._data; };\n    get name() { return this._name; };\n    get dead() { return this._dead; };\n    get topic() { return this._topic; };\n\n    handle(msg, topic, silently){\n\n        if(this.dead)\n            return;\n\n        topic = topic || this.topic;\n        let source = this.name;\n        let currentPacket = new Packet(msg, topic, source);\n\n        if(this.data.type !== DATA_TYPES.ACTION) // actions do not store data (ephemeral and immediate)\n            this._lastPacket = currentPacket;\n\n        let subscribers = [].concat(this._subscribers); // call original sensors in case subscriptions change mid loop\n        let len = subscribers.length;\n\n        if(!silently) {\n            for (let i = 0; i < len; i++) {\n                let s = subscribers[i];\n                typeof s === 'function' ? s.call(s, msg, currentPacket) : s.handle(msg, currentPacket);\n            }\n        }\n\n    };\n\n    destroy(){\n\n        if(this.dead)\n            return;\n\n        this._subscribers = null;\n        this._lastPacket = null;\n        this._dead = true;\n\n    };\n\n    add(watcher){\n\n        this._subscribers.push(watcher);\n\n    };\n\n    remove(watcher){\n\n        let i = this._subscribers.indexOf(watcher);\n\n        if(i !== -1)\n            this._subscribers.splice(i, 1);\n\n    };\n\n}\n\n\nexport default SubscriberList;\n\n","\nimport SubscriberList from './subscriberList.js';\nimport {isValid, DATA_TYPES} from './dataTypes.js';\n\nconst NO_TOPIC = '___NO_TOPIC___';\n\nclass Data {\n\n    constructor(scope, name, type) {\n\n        type = type || DATA_TYPES.NONE;\n\n        if(!isValid(type))\n            throw new Error('Invalid Data of type: ' + type);\n\n        this._scope      = scope;\n        this._name       = name;\n        this._type       = type;\n        this._dead       = false;\n\n        this._wildcardSubscriberList = new SubscriberList(null, this);\n        this._subscriberListsByTopic = new Map();\n\n    };\n\n    get scope() { return this._scope; };\n    get name() { return this._name; };\n    get type() { return this._type; };\n    get dead() { return this._dead; };\n\n    destroy(){\n\n        if(this.dead)\n            this._throwDead();\n        \n        for(const list of this._subscriberListsByTopic.values()){\n            list.destroy();\n        }\n\n        this._dead = true;\n\n    };\n    \n    _demandSubscriberList(topic){\n\n        topic = topic || undefined;\n        let list = this._subscriberListsByTopic.get(topic);\n\n        if(list)\n            return list;\n\n        list = new SubscriberList(topic, this);\n        this._subscriberListsByTopic.set(topic, list);\n\n        return list;\n        \n    };\n\n    verify(expectedType){\n\n        if(this.type === expectedType)\n            return this;\n\n        throw new Error('Data ' + this.name + ' requested as type ' + expectedType + ' exists as ' + this.type);\n\n    };\n\n    follow(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.subscribe(watcher, topic);\n        let packet = this.peek();\n\n        if(packet)\n            typeof watcher === 'function' ? watcher.call(watcher, packet.msg, packet) : watcher.handle(packet.msg, packet);\n\n        return this;\n\n    };\n\n    subscribe(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this._demandSubscriberList(topic).add(watcher);\n\n        return this;\n\n    };\n\n    monitor(watcher){\n\n        if(this.dead)\n            this._throwDead();\n\n        this._wildcardSubscriberList.add(watcher);\n\n        return this;\n\n    };\n\n    unsubscribe(watcher, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this._demandSubscriberList(topic).remove(watcher);\n        this._wildcardSubscriberList.remove(watcher);\n\n        return this;\n\n    };\n\n    topics(){\n\n        return this._subscriberListsByTopic.keys();\n\n    };\n\n    survey(){ // get entire key/value store by topic:lastPacket\n\n        const entries = this._subscriberListsByTopic.entries();\n        const m = new Map();\n        for (const [key, value] of entries) {\n            m.set(key, value.lastPacket);\n        }\n\n        return m;\n    };\n\n\n    peek(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        const subscriberList = this._subscriberListsByTopic.get(topic);\n        return subscriberList ? subscriberList.lastPacket : null;\n\n    };\n\n\n    read(topic) {\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        let packet = this.peek(topic);\n        return (packet) ? packet.msg : undefined;\n\n    };\n\n\n    silentWrite(msg, topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.write(msg, topic, true);\n\n    };\n\n\n    write(msg, topic, silently){\n\n        if(this.dead)\n            this._throwDead();\n\n        if(this.type === DATA_TYPES.MIRROR)\n            throw new Error('Mirror Data: ' + this.name + ' is read-only');\n\n        topic = topic || undefined;\n        const list = this._demandSubscriberList(topic);\n        list.handle(msg, topic, silently);\n        this._wildcardSubscriberList.handle(msg, topic, silently);\n\n    };\n\n\n    refresh(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        const lastPacket = this.peek(topic);\n\n        if(lastPacket)\n            this.write(lastPacket._msg, topic);\n\n        return this;\n\n    };\n\n\n    toggle(topic){\n\n        if(this.dead)\n            this._throwDead();\n\n        topic = topic || undefined;\n        this.write(!this.read(topic), topic);\n\n        return this;\n\n    };\n\n    _throwDead(){\n\n        throw new Error('Data: ' + this.name + ' is already dead.');\n\n    };\n\n}\n\nexport default Data;\n\n\n\n\n\n\n\n\n\n\n\n\n","\nclass PoolAspects {\n\n    constructor() {\n\n        this.until      = null;\n        this.reduce     = null;\n        this.when       = null;\n        this.clear      = null;\n        this.timer      = null;\n\n    };\n\n}\n\nexport default PoolAspects;\n\n//\n// this._keep = null; // pool storage\n// this._until = null; // stream end lifecycle -- todo switch until to when in current setup\n// this._timer = null; // release from pool timer\n// this._clear = false; // condition to clear storage on release\n// this._when = false; // invokes timer for release\n","import F from './flib.js';\nimport PoolAspects from './poolAspects.js';\n\n\nclass Frame {\n\n    constructor(bus, streams) {\n\n        streams = streams || [];\n        this._bus = bus;\n        this._index = bus._frames.length;\n        this._holding = false; //begins group, keep, schedule frames\n        this._streams = streams;\n\n        this._process = null; // name of sync process method in streams\n        this._action = null; // function defining sync stream action\n        this._isFactory = false; // whether sync action is a stateful factory function\n\n        this._poolAspects = null;\n\n        const len = streams.length;\n        for(let i = 0; i < len; i++){\n            streams[i].debugFrame = this;\n        }\n\n    };\n\n    get bus() {\n        return this._bus;\n    };\n\n    get index() {\n        return this._index;\n    };\n\n    get holding() {\n        return this._holding;\n    };\n\n    get streams() {\n        return [].concat(this._streams);\n    }\n\n    applySyncProcess(name, action, isFactory){ // generate means action function must be called to generate stateful action\n\n        this._process = name;\n        this._action = action;\n        this._isFactory = isFactory;\n\n        const streams = this._streams;\n        const len = streams.length;\n\n        if(isFactory) {\n            for (let i = 0; i < len; i++) {\n                const s = streams[i];\n                s.actionMethod = action();\n                s.processMethod = s[name];\n            }\n        } else {\n            for (let i = 0; i < len; i++) {\n                const s = streams[i];\n                s.actionMethod = action;\n                s.processMethod = s[name];\n            }\n        }\n\n        return this;\n\n    };\n\n    hold(){\n\n        this._holding = true;\n        this._poolAspects = new PoolAspects();\n\n        const streams = this._streams;\n        const len = streams.length;\n\n        for(let i = 0; i < len; i++){\n            const s = streams[i];\n            s.createPool();\n            s.processMethod = s.doPool;\n        }\n\n        return this;\n\n    };\n\n    poll(){\n\n        const streams = this._streams;\n        const len = streams.length;\n\n        for(let i = 0; i < len; i++){\n            const s = streams[i];\n            s.poll();\n        }\n\n    };\n\n    run(func, stateful){\n        return this.applySyncProcess('doRun', func, stateful);\n    };\n\n    msg(fAny, stateful){\n        return this.applySyncProcess('doMsg', F.FUNCTOR(fAny), stateful);\n    };\n\n\n    transform(fAny, stateful){\n        return this.applySyncProcess('doTransform', F.FUNCTOR(fAny), stateful);\n    };\n\n    source(fStr, stateful){\n        return this.applySyncProcess('doSource', F.FUNCTOR(fStr), stateful);\n    };\n\n    delay(fNum, stateful){\n        return this.applySyncProcess('doDelay', F.FUNCTOR(fNum), stateful);\n    };\n\n    filter(func, stateful){\n        return this.applySyncProcess('doFilter', func, stateful);\n    };\n\n    skipDupes() {\n        return this.applySyncProcess('doFilter', F.getSkipDupes, true);\n    };\n\n    clear(factory, ...args){\n        return this.buildPoolAspect('clear', factory, ...args);\n    };\n\n    // factory should define content and reset methods have signature f(msg, source) return f.content()\n\n    reduce(factory, ...args){\n        return this.buildPoolAspect('keep', factory, ...args);\n    };\n\n    timer(factory, ...args){\n        return this.buildPoolAspect('timer', factory, ...args);\n    };\n\n    when(factory, ...args){\n        return this.buildPoolAspect('when', factory, ...args);\n    };\n\n    until(factory, ...args){\n        return this.buildPoolAspect('until', factory, ...args);\n    };\n\n    buildPoolAspect(aspect, factory, ...args){\n\n        if(aspect === 'timer')\n            this._holding = false;\n\n        this._poolAspects[aspect] = [factory, ...args];\n\n        const streams = this._streams;\n        const len = streams.length;\n\n        for(let i = 0; i < len; i++){\n\n            const s = streams[i];\n            const pool = s.pool;\n            pool.build(aspect, factory, ...args);\n\n        }\n\n        return this;\n\n    };\n\n    destroy(){\n\n        const streams = this._streams;\n        const len = streams.length;\n        for(let i = 0; i < len; i++){\n            streams[i].cleanupMethod();\n        }\n        this._streams = null;\n\n    };\n    \n}\n\nexport default Frame;\n\n\n","\nimport F from './flib.js';\n\nclass Pool {\n\n    constructor(stream){\n\n        this.stream = stream;\n\n        this.keep = null;\n        this.when = F.ALWAYS_TRUE;\n        this.until = F.ALWAYS_TRUE;\n        this.timer = null; // throttle, debounce, defer, batch, sync\n        this.clear = F.ALWAYS_FALSE;\n        this.isPrimed = false;\n        this.source = stream.name;\n\n    };\n\n    handle(msg, source) {\n\n        this.keep(msg, source);\n        if(!this.isPrimed){\n            const content = this.keep.content();\n            if(this.when(content)){\n                this.isPrimed = true;\n                this.timer(this);\n            }\n        }\n\n    };\n\n    build(prop, factory, ...args){\n        this[prop] = factory.call(this, ...args);\n    };\n\n    release(pool) {\n\n        pool = pool || this;\n        const hasContent = !pool.keep.isEmpty;\n        const msg = hasContent && pool.keep.next();\n\n        if(pool.clear()){\n            pool.keep.reset();\n            pool.when.reset();\n        }\n\n        pool.isPrimed = false;\n\n        if(hasContent)\n            pool.stream.emit(msg, pool.stream.name);\n\n    };\n\n}\n\n\n\nexport default Pool;","import Pool from './pool.js';\nimport F from './flib.js';\n\nclass Stream {\n\n    constructor(){\n\n        this.debugFrame = null;\n        this.dead = false;\n        this.children = [];\n        this.name = null;\n        this.pool = null;\n        this.cleanupMethod = F.NOOP; // to cleanup subscriptions\n        this.poll = F.NOOP; // to retrieve and emit stored values from a source\n        this.processMethod = this.emit;\n        this.actionMethod = null; // for run, transform, filter, name, delay\n\n    };\n\n    handle(msg, source) {\n\n        if(this.dead) // true if canceled or disposed midstream\n            return this;\n\n        this.processMethod(msg, source); // handle method = doDelay, doGroup, doHold, , doFilter\n\n        return this;\n\n    };\n\n    drop(stream){\n\n        const children = this.children;\n        const i = children.indexOf(stream);\n\n        if(i !== -1)\n            children.splice(i, 1);\n\n    };\n\n    addTarget(stream){\n        this.children.push(stream);\n    };\n\n    emit(msg, source, topic, thisStream){\n\n        thisStream = thisStream || this; // allow callbacks with context instead of bind (massively faster)\n\n        const children = thisStream.children;\n        const len = children.length;\n\n        for(let i = 0; i < len; i++){\n            const c = children[i];\n            c.handle(msg, source, topic);\n        }\n\n    };\n\n    doFilter(msg, source, topic) {\n\n        if(!this.actionMethod(msg, source, topic))\n            return;\n        this.emit(msg, source, topic);\n\n    };\n\n\n    doMsg(msg, source, topic) {\n\n        msg = this.actionMethod(msg, source, topic);\n        this.emit(msg, source, topic);\n\n    };\n\n    doTransform(msg, source, topic) {\n\n\n        msg = this.actionMethod.msg ? this.actionMethod.msg(msg, source, topic) : msg;\n        source = this.actionMethod.source ? this.actionMethod.source(msg, source, topic) : source;\n        topic = this.actionMethod.topic ? this.actionMethod.topic(msg, source, topic) : topic;\n        this.emit(msg, source, topic);\n\n    };\n\n    doDelay(msg, source, topic) {\n\n        // todo add destroy -> kills timeout\n        // passes 'this' to avoid bind slowdown\n        setTimeout(this.emit, this.actionMethod(msg, source, topic) || 0, msg, source, topic, this);\n\n    };\n\n    doSource(msg, source, topic) {\n\n        source = this.actionMethod(msg, source, topic);\n        this.emit(msg, source, topic);\n\n    };\n\n\n    doRun(msg, source, topic) {\n\n        this.actionMethod(msg, source, topic);\n        this.emit(msg, source, topic);\n\n    };\n\n    createPool(){\n\n        this.pool = new Pool(this);\n    };\n\n    doPool(msg, source, topic) {\n\n        this.pool.handle(msg, source, topic);\n\n    };\n\n    destroy(){\n\n        if(this.dead)\n            return;\n\n        this.cleanupMethod(); // should remove an eventListener if present\n\n    };\n\n}\n\n\nStream.fromMonitor = function(data, name, canPoll){\n\n    const stream = new Stream();\n    const streamName = name || data.name;\n\n    stream.name = streamName;\n\n    const toStream = function(msg, source, topic){\n        stream.emit(msg, streamName || source, topic);\n    };\n\n    stream.cleanupMethod = function(){\n        data.unsubscribe(toStream);\n    };\n\n    if(canPoll){\n        stream.poll = function(){\n            const packet = data.survey();\n            if(packet) {\n                const msg = packet._msg;\n                const source = streamName || packet._source;\n                const topic = packet._topic;\n                stream.emit(msg, source, topic, stream);\n            }\n        }\n    }\n\n    data.monitor(toStream);\n\n    return stream;\n\n};\n\n\nStream.fromSubscribe = function(data, topic, name, canPoll){\n\n    const stream = new Stream();\n    const streamName = name || topic || data.name;\n\n    stream.name = streamName;\n\n    const toStream = function(msg, source, topic){\n        stream.emit(msg, streamName || source, topic);\n    };\n\n    stream.cleanupMethod = function(){\n        data.unsubscribe(toStream, topic);\n    };\n\n    if(canPoll){\n        stream.poll = function(){\n            const packet = data.peek();\n            if(packet) {\n                const msg = packet._msg;\n                const source = streamName || packet._source;\n                const topic = packet._topic;\n                stream.emit(msg, source, topic, stream);\n            }\n        }\n    }\n\n    data.subscribe(toStream, topic);\n\n    return stream;\n\n};\n\n\n\nStream.fromEvent = function(target, eventName, useCapture){\n\n    useCapture = !!useCapture;\n\n    const stream = new Stream();\n    stream.name = eventName;\n\n    const on = target.addEventListener || target.addListener || target.on;\n    const off = target.removeEventListener || target.removeListener || target.off;\n\n    const toStream = function(msg){\n        stream.handle(msg, eventName);\n    };\n\n    stream.cleanupMethod = function(){\n        off.call(target, eventName, toStream, useCapture);\n    };\n\n    on.call(target, eventName, toStream, useCapture);\n\n    return stream;\n\n};\n\n\nexport default Stream;","\nimport Scope from './scope.js';\nimport Stream from './stream.js';\nimport Bus from './bus.js';\nimport Nyan from './nyan.js';\n\n\nconst Catbus = {};\n\nlet _batchQueue = [];\nlet _primed = false;\n\n\n\nCatbus.fromEvent = function(target, eventName, useCapture){\n\n    const stream = Stream.fromEvent(target, eventName, useCapture);\n    return new Bus(null, [stream]);\n\n};\n\n// todo stable output queue -- output pools go in a queue that runs after the batch q is cleared, thus run once only\n\nCatbus.enqueue = function(pool){\n\n    _batchQueue.push(pool);\n\n    if(!_primed) { // register to flush the queue\n        _primed = true;\n        if (typeof window !== 'undefined' && window.requestAnimationFrame) requestAnimationFrame(Catbus.flush);\n        else process.nextTick(Catbus.flush);\n    }\n\n};\n\n\nCatbus.scope = function(name){\n\n    console.log('NYAN');\n    const k = Nyan.parse('^bunny?:error(badbunny), cow:(huh), moo2?(meow) | %kitten' +\n        '                       {*toMuffin | =order {=raw}} =meow {you} =woo');\n\n    for(const cmd of k){\n        console.log('CMD: ', cmd.name);\n        const phrase = cmd.phrase;\n        if(!phrase)\n            continue;\n        for(const word of phrase){\n            console.log(word.name, word.operation, word.maybe);\n        }\n    }\n\n    console.log(k);\n\n    console.log('root is ', name);\n    return new Scope(name);\n\n};\n\n\nCatbus.flush = function(){\n\n    _primed = false;\n\n    let cycles = 0;\n    let q = _batchQueue;\n    _batchQueue = [];\n\n    while(q.length) {\n\n        while (q.length) {\n            const pool = q.shift();\n            pool.release();\n        }\n\n        q = _batchQueue;\n        _batchQueue = [];\n\n        cycles++;\n        if(cycles > 10)\n            throw new Error('Flush batch cycling loop > 10.', q);\n\n    }\n\n};\n\n\n\nexport default Catbus;\n"],"names":["ALWAYS_TRUE","ALWAYS_FALSE","TO_SOURCE","msg","source","TO_TOPIC","topic","TO_MSG","NOOP","FUNCTOR","val","isValid","type","reverseLookup","hasOwnProperty","_wireFrames","frame1","frame2","streams1","_streams","streams2","len","length","i","s1","s2","Stream","name","push","addTarget","parse","str","isProcess","sentences","chunks","split","map","d","trim","filter","chunk","sentence","parseSentence","validate","cmdList","firstPhrase","s","j","phrase","validateReactPhrase","hasReaction","nw","operation","reactionsByName","withReactionsByName","Error","validateProcessPhrase","firstOperation","thenByName","log","result","parsePhrase","words","rawWords","rawWord","nameAndOperation","shift","firstChar","namesBySymbol","start","slice","extracts","maybe","monitor","alias","need","prop","silentFail","next","NyanWord","getPacketFromDataWord","scope","word","data","find","peek","getSurveyFromDataWord","survey","getDoSkipNamedDupes","names","lastMsg","diff","getDoRead","firstWord","getDoReadMultiple","getDoReadSingle","getDoAnd","packet","isAndOperation","key","value","getDataStream","canPoll","fromMonitor","fromSubscribe","getEventStream","node","fromEvent","useCapture","getNeedsArray","applyReaction","bus","target","skipDupes","streams","addFrame","merge","group","batch","whenKeys","applyProcess","context","needs","applyRunProcess","method","f","call","run","applyFilterProcess","nyanToBus","nyan","Nyan","cmd","fork","back","_destroyEach","arr","destroy","Func","args","func","pool","this","enqueue","release","fNum","timedRelease","fromTimeout","stream","dead","nowEmpty","keep","isEmpty","timeoutId","setTimeout","wasEmpty","msgDuringTimer","auto","n","Infinity","buffer","isBuffer","content","seed","hasSeed","arguments","acc","initMsg","reset","groupBy","hash","g","k","last","firstMsg","latched","messages","keys","keyHash","messagesByKey","hadMsg","holding","To_MSG","Packet","_msg","_topic","_source","_timestamp","Date","now","DATA_TYPES","p","v","SubscriberList","_subscribers","_lastPacket","_data","_name","_dead","silently","currentPacket","ACTION","subscribers","concat","handle","watcher","indexOf","splice","Data","NONE","_scope","_type","_wildcardSubscriberList","_subscriberListsByTopic","Map","_throwDead","values","undefined","list","get","set","expectedType","subscribe","_demandSubscriberList","add","remove","entries","m","lastPacket","subscriberList","write","MIRROR","read","PoolAspects","until","reduce","when","clear","timer","Frame","_bus","_index","_frames","_holding","_process","_action","_isFactory","_poolAspects","debugFrame","action","isFactory","actionMethod","processMethod","createPool","doPool","poll","stateful","applySyncProcess","fAny","F","fStr","getSkipDupes","factory","buildPoolAspect","aspect","build","cleanupMethod","Pool","isPrimed","hasContent","emit","children","thisStream","streamName","toStream","unsubscribe","eventName","on","addEventListener","addListener","off","removeEventListener","removeListener","Bus","_children","_parent","_busList","_currentFrame","lastFrame","nextFrame","ASSERT_NOT_HOLDING","parent","frame","getDeferTimer","getBatchTimer","getSyncTimer","getThrottleTimer","hold","e","getScan","num","ASSERT_NEED_ONE_ARGUMENT","delay","ASSERT_IS_HOLDING","getAlwaysTrue","getWhenKeys","by","getGroup","getKeepAll","getKeepFirst","getKeepLast","ASSERT_IS_FUNCTION","mergedStream","transform","frames","newParent","oldParent","operationDefs","sym","react","solo","follow","event","then","output","operationsBySymbol","operationsByName","symbolsByName","op","idCounter","Scope","_id","_dataList","_valves","_mirrors","child","mirror","Object","create","grab","_createData","verify","STATE","state","_createMirror","required","dataSet","findDataSet","appliedValves","dataList","valves","mirrors","size","has","delete","possibles","localData","foundInner","writes","Array","isArray","_multiWriteArray","_multiWriteHash","writeArray","dimension","w","silentWrite","refresh","writeHash","from","Catbus","_batchQueue","_primed","window","requestAnimationFrame","flush","process","nextTick","cycles","q"],"mappings":"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"}